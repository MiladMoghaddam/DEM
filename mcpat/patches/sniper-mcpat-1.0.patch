diff --git a/XML_Parse.cc b/XML_Parse.cc
index b0a27fc..d60c06d 100644
--- a/XML_Parse.cc
+++ b/XML_Parse.cc
@@ -104,6 +104,38 @@ void ParseXML::parse(char* filepath)
 //		exit(0);
 //	}
 
+   if (sys.number_of_cores > MAX_NUM_CORES)
+   {
+      cerr << "Cannot have more than " << MAX_NUM_CORES << " cores" << endl;
+      exit(1);
+   }
+   if (sys.number_of_L1Directories > MAX_NUM_CORES)
+   {
+      cerr << "Cannot have more than " << MAX_NUM_CORES << " L1Directories" << endl;
+      exit(1);
+   }
+   if (sys.number_of_L2Directories > MAX_NUM_CORES)
+   {
+      cerr << "Cannot have more than " << MAX_NUM_CORES << " L2Directories" << endl;
+      exit(1);
+   }
+   if (sys.number_of_L2s > MAX_NUM_CORES)
+   {
+      cerr << "Cannot have more than " << MAX_NUM_CORES << " L2s" << endl;
+      exit(1);
+   }
+   if (sys.number_of_L3s > MAX_NUM_CORES)
+   {
+      cerr << "Cannot have more than " << MAX_NUM_CORES << " L3s" << endl;
+      exit(1);
+   }
+   if (sys.number_of_NoCs > MAX_NUM_CORES)
+   {
+      cerr << "Cannot have more than " << MAX_NUM_CORES << " NoCs" << endl;
+      exit(1);
+   }
+
+
 	itmp=xNode2.nChildNode("stat");
 	for(i=0; i<itmp; i++)
 	{
diff --git a/XML_Parse.h b/XML_Parse.h
index 500497b..9c34551 100644
--- a/XML_Parse.h
+++ b/XML_Parse.h
@@ -525,6 +525,8 @@ typedef struct{
 	double total_load_perc;
 } system_pcie;
 
+const int MAX_NUM_CORES = 1024;
+
 typedef struct{
 	//All number_of_* at the level of 'system' Ying 03/21/2009
 	int number_of_cores;
@@ -571,12 +573,12 @@ typedef struct{
     double total_cycles;
     double vdd;
 	//system.core(0-n):3rd level
-	system_core core[64];
-	system_L1Directory L1Directory[64];
-	system_L2Directory L2Directory[64];
-	system_L2 L2[64];
-	system_L3 L3[64];
-    system_NoC NoC[64];
+	system_core core[MAX_NUM_CORES];
+	system_L1Directory L1Directory[MAX_NUM_CORES];
+	system_L2Directory L2Directory[MAX_NUM_CORES];
+	system_L2 L2[MAX_NUM_CORES];
+	system_L3 L3[MAX_NUM_CORES];
+    system_NoC NoC[MAX_NUM_CORES];
     system_mem mem;
 	system_mc mc;
 	system_mc flashc;
diff --git a/array.cc b/array.cc
index 80b8ac6..0ba8033 100644
--- a/array.cc
+++ b/array.cc
@@ -134,7 +134,7 @@ void ArrayST::optimize_array()
 
 			//		from best area to worst area -->worst timing to best timing
 			if ((((local_result.cycle_time - throughput) <= 1e-10 ) && (local_result.access_time - latency)<= 1e-10)||
-					(local_result.data_array2->area_efficiency < area_efficiency_threshold && l_ip.assoc == 0))
+					(local_result.data_array2.area_efficiency < area_efficiency_threshold && l_ip.assoc == 0))
 			{  //if no satisfiable solution is found,the most aggressive one is left
 				candidate_solutions.push_back(local_result);
 				//output_data_csv(candidate_solutions.back());
@@ -253,34 +253,34 @@ void ArrayST::optimize_array()
 	local_result.power = local_result.power* pppm_t;
 
 
-	local_result.data_array2->power.readOp.dynamic *= sckRation;
-	local_result.data_array2->power.writeOp.dynamic *= sckRation;
-	local_result.data_array2->power.searchOp.dynamic *= sckRation;
-	local_result.data_array2->power.readOp.leakage *= l_ip.nbanks;
-	local_result.data_array2->power.readOp.longer_channel_leakage =
-		local_result.data_array2->power.readOp.leakage*long_channel_device_reduction;
+	local_result.data_array2.power.readOp.dynamic *= sckRation;
+	local_result.data_array2.power.writeOp.dynamic *= sckRation;
+	local_result.data_array2.power.searchOp.dynamic *= sckRation;
+	local_result.data_array2.power.readOp.leakage *= l_ip.nbanks;
+	local_result.data_array2.power.readOp.longer_channel_leakage =
+		local_result.data_array2.power.readOp.leakage*long_channel_device_reduction;
 	if (l_ip.assoc==0)//only use this function for CAM/FA since other array types compute pg leakage automatically
 	{
-		local_result.data_array2->power.readOp.power_gated_leakage =
-			local_result.data_array2->power.readOp.leakage*pg_reduction;
+		local_result.data_array2.power.readOp.power_gated_leakage =
+			local_result.data_array2.power.readOp.leakage*pg_reduction;
 	}
 	else
 	{
-		local_result.data_array2->power.readOp.power_gated_leakage *= l_ip.nbanks;//normal array types
+		local_result.data_array2.power.readOp.power_gated_leakage *= l_ip.nbanks;//normal array types
 	}
-	local_result.data_array2->power = local_result.data_array2->power* pppm_t;
+	local_result.data_array2.power = local_result.data_array2.power* pppm_t;
 
 
 	if (!(l_ip.pure_cam || l_ip.pure_ram || l_ip.fully_assoc) && l_ip.is_cache)
 	{
-		local_result.tag_array2->power.readOp.dynamic *= sckRation;
-		local_result.tag_array2->power.writeOp.dynamic *= sckRation;
-		local_result.tag_array2->power.searchOp.dynamic *= sckRation;
-		local_result.tag_array2->power.readOp.leakage *= l_ip.nbanks;
-		local_result.data_array2->power.readOp.power_gated_leakage *= l_ip.nbanks;
-		local_result.tag_array2->power.readOp.longer_channel_leakage =
-			local_result.tag_array2->power.readOp.leakage*long_channel_device_reduction;
-		local_result.tag_array2->power = local_result.tag_array2->power* pppm_t;
+		local_result.tag_array2.power.readOp.dynamic *= sckRation;
+		local_result.tag_array2.power.writeOp.dynamic *= sckRation;
+		local_result.tag_array2.power.searchOp.dynamic *= sckRation;
+		local_result.tag_array2.power.readOp.leakage *= l_ip.nbanks;
+		local_result.data_array2.power.readOp.power_gated_leakage *= l_ip.nbanks;
+		local_result.tag_array2.power.readOp.longer_channel_leakage =
+			local_result.tag_array2.power.readOp.leakage*long_channel_device_reduction;
+		local_result.tag_array2.power = local_result.tag_array2.power* pppm_t;
 	}
 
 
@@ -311,21 +311,21 @@ void ArrayST::leakage_feedback(double temperature)//TODO: add the code to proces
   local_result.power.readOp.longer_channel_leakage = local_result.power.readOp.leakage*long_channel_device_reduction;
   local_result.power = local_result.power* pppm_t;
 
-  local_result.data_array2->power.readOp.dynamic *= sckRation;
-  local_result.data_array2->power.writeOp.dynamic *= sckRation;
-  local_result.data_array2->power.searchOp.dynamic *= sckRation;
-  local_result.data_array2->power.readOp.leakage *= l_ip.nbanks;
-  local_result.data_array2->power.readOp.longer_channel_leakage = local_result.data_array2->power.readOp.leakage*long_channel_device_reduction;
-  local_result.data_array2->power = local_result.data_array2->power* pppm_t;
+  local_result.data_array2.power.readOp.dynamic *= sckRation;
+  local_result.data_array2.power.writeOp.dynamic *= sckRation;
+  local_result.data_array2.power.searchOp.dynamic *= sckRation;
+  local_result.data_array2.power.readOp.leakage *= l_ip.nbanks;
+  local_result.data_array2.power.readOp.longer_channel_leakage = local_result.data_array2.power.readOp.leakage*long_channel_device_reduction;
+  local_result.data_array2.power = local_result.data_array2.power* pppm_t;
 
   if (!(l_ip.pure_cam || l_ip.pure_ram || l_ip.fully_assoc) && l_ip.is_cache)
   {
-    local_result.tag_array2->power.readOp.dynamic *= sckRation;
-    local_result.tag_array2->power.writeOp.dynamic *= sckRation;
-    local_result.tag_array2->power.searchOp.dynamic *= sckRation;
-    local_result.tag_array2->power.readOp.leakage *= l_ip.nbanks;
-    local_result.tag_array2->power.readOp.longer_channel_leakage = local_result.tag_array2->power.readOp.leakage*long_channel_device_reduction;
-    local_result.tag_array2->power = local_result.tag_array2->power* pppm_t;
+    local_result.tag_array2.power.readOp.dynamic *= sckRation;
+    local_result.tag_array2.power.writeOp.dynamic *= sckRation;
+    local_result.tag_array2.power.searchOp.dynamic *= sckRation;
+    local_result.tag_array2.power.readOp.leakage *= l_ip.nbanks;
+    local_result.tag_array2.power.readOp.longer_channel_leakage = local_result.tag_array2.power.readOp.leakage*long_channel_device_reduction;
+    local_result.tag_array2.power = local_result.tag_array2.power* pppm_t;
   }
 }
 
diff --git a/cacti/Ucache.cc b/cacti/Ucache.cc
index 946ed9d..390e4b0 100644
--- a/cacti/Ucache.cc
+++ b/cacti/Ucache.cc
@@ -498,48 +498,48 @@ void collect_uca_results(
 }
 
 
-bool check_uca_org(uca_org_t & u, min_values_t *minval)
+bool check_uca_org(uca_org_t & u, const min_values_t & minval)
 {
-  if (((u.access_time - minval->min_delay)*100/minval->min_delay) > g_ip->delay_dev) {
+  if (((u.access_time - minval.min_delay)*100/minval.min_delay) > g_ip->delay_dev) {
     return false;
   }
-  if (((u.power.readOp.dynamic - minval->min_dyn)/minval->min_dyn)*100 >
+  if (((u.power.readOp.dynamic - minval.min_dyn)/minval.min_dyn)*100 >
       g_ip->dynamic_power_dev) {
     return false;
   }
-  if (((u.power.readOp.leakage - minval->min_leakage)/minval->min_leakage)*100 >
+  if (((u.power.readOp.leakage - minval.min_leakage)/minval.min_leakage)*100 >
       g_ip->leakage_power_dev) {
     return false;
   }
-  if (((u.cycle_time - minval->min_cyc)/minval->min_cyc)*100 >
+  if (((u.cycle_time - minval.min_cyc)/minval.min_cyc)*100 >
       g_ip->cycle_time_dev) {
     return false;
   }
-  if (((u.area - minval->min_area)/minval->min_area)*100 >
+  if (((u.area - minval.min_area)/minval.min_area)*100 >
       g_ip->area_dev) {
     return false;
   }
   return true;
 }
 
-bool check_mem_org(mem_array & u, const min_values_t *minval)
+bool check_mem_org(mem_array & u, const min_values_t & minval)
 {
-  if (((u.access_time - minval->min_delay)*100/minval->min_delay) > g_ip->delay_dev) {
+  if (((u.access_time - minval.min_delay)*100/minval.min_delay) > g_ip->delay_dev) {
     return false;
   }
-  if (((u.power.readOp.dynamic - minval->min_dyn)/minval->min_dyn)*100 >
+  if (((u.power.readOp.dynamic - minval.min_dyn)/minval.min_dyn)*100 >
       g_ip->dynamic_power_dev) {
     return false;
   }
-  if (((u.power.readOp.leakage - minval->min_leakage)/minval->min_leakage)*100 >
+  if (((u.power.readOp.leakage - minval.min_leakage)/minval.min_leakage)*100 >
       g_ip->leakage_power_dev) {
     return false;
   }
-  if (((u.cycle_time - minval->min_cyc)/minval->min_cyc)*100 >
+  if (((u.cycle_time - minval.min_cyc)/minval.min_cyc)*100 >
       g_ip->cycle_time_dev) {
     return false;
   }
-  if (((u.area - minval->min_area)/minval->min_area)*100 >
+  if (((u.area - minval.min_area)/minval.min_area)*100 >
       g_ip->area_dev) {
     return false;
   }
@@ -549,7 +549,7 @@ bool check_mem_org(mem_array & u, const min_values_t *minval)
 
 
 
-void find_optimal_uca(uca_org_t *res, min_values_t * minval, list<uca_org_t> & ulist)
+void find_optimal_uca(uca_org_t * res, const min_values_t & minval, list<uca_org_t> & ulist)
 {
   double cost = 0;
   double min_cost = BIGNUM;
@@ -571,7 +571,7 @@ void find_optimal_uca(uca_org_t *res, min_values_t * minval, list<uca_org_t> & u
   {
     if (g_ip->ed == 1)
     {
-      cost = ((niter)->access_time/minval->min_delay) * ((niter)->power.readOp.dynamic/minval->min_dyn);
+      cost = ((niter)->access_time/minval.min_delay) * ((niter)->power.readOp.dynamic/minval.min_dyn);
       if (min_cost > cost)
       {
         min_cost = cost;
@@ -580,9 +580,9 @@ void find_optimal_uca(uca_org_t *res, min_values_t * minval, list<uca_org_t> & u
     }
     else if (g_ip->ed == 2)
     {
-      cost = ((niter)->access_time/minval->min_delay)*
-             ((niter)->access_time/minval->min_delay)*
-             ((niter)->power.readOp.dynamic/minval->min_dyn);
+      cost = ((niter)->access_time/minval.min_delay)*
+             ((niter)->access_time/minval.min_delay)*
+             ((niter)->power.readOp.dynamic/minval.min_dyn);
       if (min_cost > cost)
       {
         min_cost = cost;
@@ -600,11 +600,11 @@ void find_optimal_uca(uca_org_t *res, min_values_t * minval, list<uca_org_t> & u
 
       if (v)
       {
-        cost = (d  * ((niter)->access_time/minval->min_delay) +
-                c  * ((niter)->cycle_time/minval->min_cyc) +
-                dp * ((niter)->power.readOp.dynamic/minval->min_dyn) +
-                lp * ((niter)->power.readOp.leakage/minval->min_leakage) +
-                a  * ((niter)->area/minval->min_area));
+        cost = (d  * ((niter)->access_time/minval.min_delay) +
+                c  * ((niter)->cycle_time/minval.min_cyc) +
+                dp * ((niter)->power.readOp.dynamic/minval.min_dyn) +
+                lp * ((niter)->power.readOp.leakage/minval.min_leakage) +
+                a  * ((niter)->area/minval.min_area));
         //fprintf(stderr, "cost = %g\n", cost);
 
         if (min_cost > cost) {
@@ -632,7 +632,7 @@ void find_optimal_uca(uca_org_t *res, min_values_t * minval, list<uca_org_t> & u
 
 
 
-void filter_tag_arr(const min_values_t * min, list<mem_array *> & list)
+void filter_tag_arr(const min_values_t & min, list<mem_array *> & list)
 {
   double cost = BIGNUM;
   double cur_cost;
@@ -651,11 +651,11 @@ void filter_tag_arr(const min_values_t * min, list<mem_array *> & list)
     bool v = check_mem_org(*list.back(), min);
     if (v)
     {
-      cur_cost = wt_delay   * (list.back()->access_time/min->min_delay) +
-        wt_dyn     * (list.back()->power.readOp.dynamic/min->min_dyn) +
-        wt_leakage * (list.back()->power.readOp.leakage/min->min_leakage) +
-        wt_area    * (list.back()->area/min->min_area) +
-        wt_cyc     * (list.back()->cycle_time/min->min_cyc);
+      cur_cost = wt_delay   * (list.back()->access_time/min.min_delay) +
+        wt_dyn     * (list.back()->power.readOp.dynamic/min.min_dyn) +
+        wt_leakage * (list.back()->power.readOp.leakage/min.min_leakage) +
+        wt_area    * (list.back()->area/min.min_area) +
+        wt_cyc     * (list.back()->cycle_time/min.min_cyc);
     }
     else
     {
@@ -703,8 +703,8 @@ void filter_data_arr(list<mem_array *> & curr_list)
 
     if (m == NULL) exit(1);
 
-    if(((m->access_time - m->arr_min->min_delay)/m->arr_min->min_delay > 0.5) &&
-       ((m->power.readOp.dynamic - m->arr_min->min_dyn)/m->arr_min->min_dyn > 0.5))
+    if(((m->access_time - m->arr_min.min_delay)/m->arr_min.min_delay > 0.5) &&
+       ((m->power.readOp.dynamic - m->arr_min.min_dyn)/m->arr_min.min_dyn > 0.5))
     {
       delete m;
       iter = curr_list.erase(iter);
@@ -835,14 +835,14 @@ void solve(uca_org_t *fin_res)
 //  }
 
 
-  min_values_t * d_min = new min_values_t();
-  min_values_t * t_min = new min_values_t();
-  min_values_t * cache_min = new min_values_t();
+  min_values_t d_min = min_values_t();
+  min_values_t t_min = min_values_t();
+  min_values_t cache_min = min_values_t();
 
   for (uint32_t t = 0; t < nthreads; t++)
   {
-    d_min->update_min_values(calc_array[t].data_res);
-    t_min->update_min_values(calc_array[t].tag_res);
+    d_min.update_min_values(calc_array[t].data_res);
+    t_min.update_min_values(calc_array[t].tag_res);
   }
 
   for (miter = data_arr.begin(); miter != data_arr.end(); miter++)
@@ -865,8 +865,8 @@ void solve(uca_org_t *fin_res)
     for (miter = data_arr.begin(); miter != data_arr.end(); miter++)
     {
       uca_org_t & curr_org  = sol_list.back(); //essentially adds value to sol_list, with no extra memory copying.
-      curr_org.tag_array2  = NULL;
-      curr_org.data_array2 = (*miter);
+      //curr_org.tag_array2  = NULL;
+      curr_org.data_array2 = *(*miter);
 
       curr_org.find_delay();
       curr_org.find_energy();
@@ -874,7 +874,7 @@ void solve(uca_org_t *fin_res)
       curr_org.find_cyc();
 
       //update min values for the entire cache
-      cache_min->update_min_values(curr_org);
+      cache_min.update_min_values(curr_org);
 
       sol_list.push_back(uca_org_t());//add a new node to the back
     }
@@ -890,8 +890,8 @@ void solve(uca_org_t *fin_res)
       for (miter = data_arr.begin(); miter != data_arr.end(); miter++)
       {
         uca_org_t & curr_org  = sol_list.back();
-        curr_org.tag_array2  = arr_temp;
-        curr_org.data_array2 = (*miter); //try all combinations of tag and data array
+        curr_org.tag_array2  = *arr_temp;
+        curr_org.data_array2 = *(*miter); //try all combinations of tag and data array
 
         curr_org.find_delay();
         curr_org.find_energy();
@@ -899,7 +899,7 @@ void solve(uca_org_t *fin_res)
         curr_org.find_cyc();
 
         //update min values for the entire cache
-        cache_min->update_min_values(curr_org);
+        cache_min.update_min_values(curr_org);
 
         sol_list.push_back(uca_org_t());
       }
@@ -912,13 +912,6 @@ void solve(uca_org_t *fin_res)
 
   sol_list.clear();
 
-  for (miter = data_arr.begin(); miter != data_arr.end(); ++miter)
-  {
-    if (*miter != fin_res->data_array2)
-    {
-      delete *miter;
-    }
-  }
   data_arr.clear();
 
   for (uint32_t t = 0; t < nthreads; t++)
@@ -928,14 +921,11 @@ void solve(uca_org_t *fin_res)
   }
 
   delete [] calc_array;
-  delete cache_min;
-  delete d_min;
-  delete t_min;
 }
 
 void update_dvs(uca_org_t *fin_res)
 {
-	if(fin_res->tag_array2 || fin_res->data_array2)
+	if(1 /*fin_res->tag_array2 || fin_res->data_array2*/)
 	{
 //		Wire::print_wire();
 		Wire winit;//init before changing dvs
@@ -962,26 +952,26 @@ void update_dvs(uca_org_t *fin_res)
 			winit.wire_dvs_update();//Wire::wire_dvs_update();//Wire winit (1,1, false);
 //			Wire::print_wire();
 
-			if(fin_res->tag_array2)
+			if(1/*fin_res->tag_array2*/)
 			{
-				DynamicParameter tag_arr_dyn_p(true, g_ip->pure_ram, g_ip->pure_cam, fin_res->tag_array2->Nspd, fin_res->tag_array2->Ndwl, fin_res->tag_array2->Ndbl, fin_res->tag_array2->deg_bl_muxing, fin_res->tag_array2->Ndsam_lev_1, fin_res->tag_array2->Ndsam_lev_2, g_ip->is_main_mem);
+				DynamicParameter tag_arr_dyn_p(true, g_ip->pure_ram, g_ip->pure_cam, fin_res->tag_array2.Nspd, fin_res->tag_array2.Ndwl, fin_res->tag_array2.Ndbl, fin_res->tag_array2.deg_bl_muxing, fin_res->tag_array2.Ndsam_lev_1, fin_res->tag_array2.Ndsam_lev_2, g_ip->is_main_mem);
 				if(tag_arr_dyn_p.is_valid)
 				{
 
 					UCA * tag_arr = new UCA(tag_arr_dyn_p);
-					fin_res->uca_q[i]->tag_array2 = new mem_array();
+					//fin_res->uca_q[i]->tag_array2 = new mem_array();
 
-					collect_uca_results(fin_res->tag_array2->Nspd, fin_res->tag_array2->Ndwl, fin_res->tag_array2->Ndbl, fin_res->tag_array2->deg_bl_muxing, fin_res->tag_array2->Ndsam_lev_1, fin_res->tag_array2->Ndsam_lev_2, tag_arr, fin_res->uca_q[i]->tag_array2, g_ip->is_main_mem);
+					collect_uca_results(fin_res->tag_array2.Nspd, fin_res->tag_array2.Ndwl, fin_res->tag_array2.Ndbl, fin_res->tag_array2.deg_bl_muxing, fin_res->tag_array2.Ndsam_lev_1, fin_res->tag_array2.Ndsam_lev_2, tag_arr, &fin_res->uca_q[i]->tag_array2, g_ip->is_main_mem);
 					delete tag_arr;
 				}
 
 			}
-			DynamicParameter data_arr_dyn_p(false, g_ip->pure_ram, g_ip->pure_cam, fin_res->data_array2->Nspd, fin_res->data_array2->Ndwl, fin_res->data_array2->Ndbl, fin_res->data_array2->deg_bl_muxing, fin_res->data_array2->Ndsam_lev_1, fin_res->data_array2->Ndsam_lev_2, g_ip->is_main_mem);
+			DynamicParameter data_arr_dyn_p(false, g_ip->pure_ram, g_ip->pure_cam, fin_res->data_array2.Nspd, fin_res->data_array2.Ndwl, fin_res->data_array2.Ndbl, fin_res->data_array2.deg_bl_muxing, fin_res->data_array2.Ndsam_lev_1, fin_res->data_array2.Ndsam_lev_2, g_ip->is_main_mem);
 			if(data_arr_dyn_p.is_valid)
 			{
 				UCA * data_arr = new UCA(data_arr_dyn_p);
-				fin_res->uca_q[i]->data_array2 = new mem_array();
-				collect_uca_results(fin_res->data_array2->Nspd, fin_res->data_array2->Ndwl, fin_res->data_array2->Ndbl, fin_res->data_array2->deg_bl_muxing, fin_res->data_array2->Ndsam_lev_1, fin_res->data_array2->Ndsam_lev_2, data_arr, fin_res->uca_q[i]->data_array2, g_ip->is_main_mem);
+				//fin_res->uca_q[i]->data_array2 = new mem_array();
+				collect_uca_results(fin_res->data_array2.Nspd, fin_res->data_array2.Ndwl, fin_res->data_array2.Ndbl, fin_res->data_array2.deg_bl_muxing, fin_res->data_array2.Ndsam_lev_1, fin_res->data_array2.Ndsam_lev_2, data_arr, &fin_res->uca_q[i]->data_array2, g_ip->is_main_mem);
 				delete data_arr;
 			}
 
@@ -1009,7 +999,7 @@ void update_dvs(uca_org_t *fin_res)
 void update_pg(uca_org_t *fin_res)
 {
 
-	if(fin_res->tag_array2 || fin_res->data_array2)
+	if(1 /*fin_res->tag_array2 || fin_res->data_array2*/)
 	{
 		Wire winit;
 		fin_res->uca_pg_reference = new uca_org_t();
@@ -1036,29 +1026,29 @@ void update_pg(uca_org_t *fin_res)
 //		init_tech_params(g_ip->F_sz_um,true);
 //		winit.wire_dvs_update();//Wire::wire_dvs_update();//Wire winit (1,1, false);
 //		Wire::print_wire();
-		if(fin_res->tag_array2)
+		if(1/*fin_res->tag_array2*/)
 		{
 			//			init_tech_params(g_ip->F_sz_um,true);
-			DynamicParameter tag_arr_dyn_p(true, g_ip->pure_ram, g_ip->pure_cam, fin_res->tag_array2->Nspd, fin_res->tag_array2->Ndwl, fin_res->tag_array2->Ndbl, fin_res->tag_array2->deg_bl_muxing, fin_res->tag_array2->Ndsam_lev_1, fin_res->tag_array2->Ndsam_lev_2, g_ip->is_main_mem);
+			DynamicParameter tag_arr_dyn_p(true, g_ip->pure_ram, g_ip->pure_cam, fin_res->tag_array2.Nspd, fin_res->tag_array2.Ndwl, fin_res->tag_array2.Ndbl, fin_res->tag_array2.deg_bl_muxing, fin_res->tag_array2.Ndsam_lev_1, fin_res->tag_array2.Ndsam_lev_2, g_ip->is_main_mem);
 			if(tag_arr_dyn_p.is_valid)
 			{
 
 				UCA * tag_arr = new UCA(tag_arr_dyn_p);
-				fin_res->uca_pg_reference->tag_array2 = new mem_array();
+				//fin_res->uca_pg_reference->tag_array2 = new mem_array();
 
-				collect_uca_results(fin_res->tag_array2->Nspd, fin_res->tag_array2->Ndwl, fin_res->tag_array2->Ndbl, fin_res->tag_array2->deg_bl_muxing, fin_res->tag_array2->Ndsam_lev_1, fin_res->tag_array2->Ndsam_lev_2, tag_arr, fin_res->uca_pg_reference->tag_array2, g_ip->is_main_mem);
+				collect_uca_results(fin_res->tag_array2.Nspd, fin_res->tag_array2.Ndwl, fin_res->tag_array2.Ndbl, fin_res->tag_array2.deg_bl_muxing, fin_res->tag_array2.Ndsam_lev_1, fin_res->tag_array2.Ndsam_lev_2, tag_arr, &fin_res->uca_pg_reference->tag_array2, g_ip->is_main_mem);
 				delete tag_arr;
 
 			}
 
 		}
 		//		init_tech_params(g_ip->F_sz_um,false);
-		DynamicParameter data_arr_dyn_p(false, g_ip->pure_ram, g_ip->pure_cam, fin_res->data_array2->Nspd, fin_res->data_array2->Ndwl, fin_res->data_array2->Ndbl, fin_res->data_array2->deg_bl_muxing, fin_res->data_array2->Ndsam_lev_1, fin_res->data_array2->Ndsam_lev_2, g_ip->is_main_mem);
+		DynamicParameter data_arr_dyn_p(false, g_ip->pure_ram, g_ip->pure_cam, fin_res->data_array2.Nspd, fin_res->data_array2.Ndwl, fin_res->data_array2.Ndbl, fin_res->data_array2.deg_bl_muxing, fin_res->data_array2.Ndsam_lev_1, fin_res->data_array2.Ndsam_lev_2, g_ip->is_main_mem);
 		if(data_arr_dyn_p.is_valid)
 		{
 			UCA * data_arr = new UCA(data_arr_dyn_p);
-			fin_res->uca_pg_reference->data_array2 = new mem_array();
-			collect_uca_results(fin_res->data_array2->Nspd, fin_res->data_array2->Ndwl, fin_res->data_array2->Ndbl, fin_res->data_array2->deg_bl_muxing, fin_res->data_array2->Ndsam_lev_1, fin_res->data_array2->Ndsam_lev_2, data_arr, fin_res->uca_pg_reference->data_array2, g_ip->is_main_mem);
+			//fin_res->uca_pg_reference->data_array2 = new mem_array();
+			collect_uca_results(fin_res->data_array2.Nspd, fin_res->data_array2.Ndwl, fin_res->data_array2.Ndbl, fin_res->data_array2.deg_bl_muxing, fin_res->data_array2.Ndsam_lev_1, fin_res->data_array2.Ndsam_lev_2, data_arr, &fin_res->uca_pg_reference->data_array2, g_ip->is_main_mem);
 			delete data_arr;
 		}
 
diff --git a/cacti/Ucache.h b/cacti/Ucache.h
index ccd65ee..03fb12b 100644
--- a/cacti/Ucache.h
+++ b/cacti/Ucache.h
@@ -40,23 +40,6 @@
 #include "uca.h"
 
 
-class min_values_t
-{
-  public:
-    double min_delay;
-    double min_dyn;
-    double min_leakage;
-    double min_area;
-    double min_cyc;
-
-    min_values_t() : min_delay(BIGNUM), min_dyn(BIGNUM), min_leakage(BIGNUM), min_area(BIGNUM), min_cyc(BIGNUM) { }
-
-    void update_min_values(const min_values_t * val);
-    void update_min_values(const uca_org_t & res);
-    void update_min_values(const nuca_org_t * res);
-    void update_min_values(const mem_array * res);
-};
-
 
 
 struct solution
diff --git a/cacti/cacti_interface.cc b/cacti/cacti_interface.cc
index a337c8a..d00c078 100644
--- a/cacti/cacti_interface.cc
+++ b/cacti/cacti_interface.cc
@@ -68,13 +68,13 @@ bool mem_array::lt(const mem_array * m1, const mem_array * m2)
 
 void uca_org_t::find_delay()
 {
-  mem_array * data_arr = data_array2;
-  mem_array * tag_arr  = tag_array2;
+  mem_array & data_arr = data_array2;
+  mem_array & tag_arr  = tag_array2;
 
   // check whether it is a regular cache or scratch ram
   if (g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)
   {
-    access_time = data_arr->access_time;
+    access_time = data_arr.access_time;
   }
   // Both tag and data lookup happen in parallel
   // and the entire set is sent over the data array h-tree without
@@ -82,23 +82,23 @@ void uca_org_t::find_delay()
   // power overhead Nav
   else if (g_ip->fast_access == true)
   {
-    access_time = MAX(tag_arr->access_time, data_arr->access_time);
+    access_time = MAX(tag_arr.access_time, data_arr.access_time);
   }
   // Tag is accessed first. On a hit, way-select signal along with the
   // address is sent to read/write the appropriate block in the data
   // array
   else if (g_ip->is_seq_acc == true)
   {
-    access_time = tag_arr->access_time + data_arr->access_time;
+    access_time = tag_arr.access_time + data_arr.access_time;
   }
   // Normal access: tag array access and data array access happen in parallel.
   // But, the data array will wait for the way-select and transfer only the
   // appropriate block over the h-tree.
   else
   {
-    access_time = MAX(tag_arr->access_time + data_arr->delay_senseamp_mux_decoder,
-                      data_arr->delay_before_subarray_output_driver) +
-                  data_arr->delay_from_subarray_output_driver_to_output;
+    access_time = MAX(tag_arr.access_time + data_arr.delay_senseamp_mux_decoder,
+                      data_arr.delay_before_subarray_output_driver) +
+                  data_arr.delay_from_subarray_output_driver_to_output;
   }
 }
 
@@ -107,9 +107,9 @@ void uca_org_t::find_delay()
 void uca_org_t::find_energy()
 {
   if (!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc))//(g_ip->is_cache)
-    power = data_array2->power + tag_array2->power;
+    power = data_array2.power + tag_array2.power;
   else
-    power = data_array2->power;
+    power = data_array2.power;
 }
 
 
@@ -118,13 +118,13 @@ void uca_org_t::find_area()
 {
   if (g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)//(g_ip->is_cache == false)
   {
-    cache_ht  = data_array2->height;
-    cache_len = data_array2->width;
+    cache_ht  = data_array2.height;
+    cache_len = data_array2.width;
   }
   else
   {
-    cache_ht  = MAX(tag_array2->height, data_array2->height);
-    cache_len = tag_array2->width + data_array2->width;
+    cache_ht  = MAX(tag_array2.height, data_array2.height);
+    cache_len = tag_array2.width + data_array2.width;
   }
   area = cache_ht * cache_len;
 }
@@ -134,10 +134,10 @@ void uca_org_t::adjust_area()
   double area_adjust;
   if (g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)
   {
-    if (data_array2->area_efficiency/100.0<0.2)
+    if (data_array2.area_efficiency/100.0<0.2)
     {
-    	//area_adjust = sqrt(area/(area*(data_array2->area_efficiency/100.0)/0.2));
-    	area_adjust = sqrt(0.2/(data_array2->area_efficiency/100.0));
+    	//area_adjust = sqrt(area/(area*(data_array2.area_efficiency/100.0)/0.2));
+    	area_adjust = sqrt(0.2/(data_array2.area_efficiency/100.0));
     	cache_ht  = cache_ht/area_adjust;
     	cache_len = cache_len/area_adjust;
     }
@@ -149,48 +149,26 @@ void uca_org_t::find_cyc()
 {
   if ((g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc))//(g_ip->is_cache == false)
   {
-    cycle_time = data_array2->cycle_time;
+    cycle_time = data_array2.cycle_time;
   }
   else
   {
-    cycle_time = MAX(tag_array2->cycle_time,
-                    data_array2->cycle_time);
+    cycle_time = MAX(tag_array2.cycle_time,
+                    data_array2.cycle_time);
   }
 }
 
 uca_org_t :: uca_org_t()
-:tag_array2(0),
- data_array2(0),
- uca_pg_reference(0)
+:uca_pg_reference(0)
 {
 	uca_q = vector<uca_org_t * >(0);
 }
 
 void uca_org_t :: cleanup()
 {
-	//	uca_org_t * it_uca_org;
-	if (data_array2!=0){
-		delete data_array2;
-		data_array2 =0;
-	}
-
-	if (tag_array2!=0){
-		delete tag_array2;
-		tag_array2 =0;
-	}
-
 	std::vector<uca_org_t * >::size_type sz = uca_q.size();
 	for (int i=sz-1; i>=0; i--)
 	{
-		if (uca_q[i]->data_array2!=0)
-		{
-			delete uca_q[i]->data_array2;
-			uca_q[i]->data_array2 =0;
-		}
-		if (uca_q[i]->tag_array2!=0){
-			delete uca_q[i]->tag_array2;
-			uca_q[i]->tag_array2 =0;
-		}
 		delete uca_q[i];
 		uca_q[i] =0;
 		uca_q.pop_back();
@@ -198,15 +176,6 @@ void uca_org_t :: cleanup()
 
 	if (uca_pg_reference!=0)
 	{
-		if (uca_pg_reference->data_array2!=0)
-		{
-			delete uca_pg_reference->data_array2;
-			uca_pg_reference->data_array2 =0;
-		}
-		if (uca_pg_reference->tag_array2!=0){
-			delete uca_pg_reference->tag_array2;
-			uca_pg_reference->tag_array2 =0;
-		}
 		delete uca_pg_reference;
 		uca_pg_reference =0;
 	}
diff --git a/cacti/cacti_interface.h b/cacti/cacti_interface.h
index 826f434..4b459d5 100644
--- a/cacti/cacti_interface.h
+++ b/cacti/cacti_interface.h
@@ -44,9 +44,9 @@
 using namespace std;
 
 
-class min_values_t;
-class mem_array;
 class uca_org_t;
+class nuca_org_t;
+class mem_array;
 
 
 class powerComponents
@@ -121,6 +121,8 @@ class InputParameter
     bool error_checking();  // return false if the input parameters are problematic
     void display_ip();
 
+    long first; // used to know where the interesting data is
+
     unsigned int cache_sz;  // in bytes
     unsigned int line_sz;
     unsigned int assoc;
@@ -224,9 +226,11 @@ class InputParameter
 
   bool cl_vertical;
 
-  std::vector<double> dvs_voltage;
-
   bool long_channel_device;
+
+    long last; // used to know where the interesting data is
+
+  std::vector<double> dvs_voltage;
 };
 
 
@@ -378,11 +382,132 @@ typedef struct{
 } results_mem_array;
 
 
+class min_values_t
+{
+  public:
+    double min_delay;
+    double min_dyn;
+    double min_leakage;
+    double min_area;
+    double min_cyc;
+
+    min_values_t() : min_delay(BIGNUM), min_dyn(BIGNUM), min_leakage(BIGNUM), min_area(BIGNUM), min_cyc(BIGNUM) { }
+
+    void update_min_values(const min_values_t * val);
+    void update_min_values(const uca_org_t & res);
+    void update_min_values(const nuca_org_t * res);
+    void update_min_values(const mem_array * res);
+};
+
+
+class mem_array
+{
+  public:
+  int    Ndcm;
+  int    Ndwl;
+  int    Ndbl;
+  double Nspd;
+  int    deg_bl_muxing;
+  int    Ndsam_lev_1;
+  int    Ndsam_lev_2;
+  double access_time;
+  double cycle_time;
+  double multisubbank_interleave_cycle_time;
+  double area_ram_cells;
+  double area;
+  powerDef power;
+  double delay_senseamp_mux_decoder;
+  double delay_before_subarray_output_driver;
+  double delay_from_subarray_output_driver_to_output;
+  double height;
+  double width;
+
+  double mat_height;
+  double mat_length;
+  double subarray_length;
+  double subarray_height;
+
+  double delay_route_to_bank,
+         delay_input_htree,
+         delay_row_predecode_driver_and_block,
+         delay_row_decoder,
+         delay_bitlines,
+         delay_sense_amp,
+         delay_subarray_output_driver,
+         delay_dout_htree,
+         delay_comparator,
+         delay_matchlines;
+
+  double all_banks_height,
+         all_banks_width,
+         area_efficiency;
+
+  powerDef power_routing_to_bank;
+  powerDef power_addr_input_htree;
+  powerDef power_data_input_htree;
+  powerDef power_data_output_htree;
+  powerDef power_htree_in_search;
+  powerDef power_htree_out_search;
+  powerDef power_row_predecoder_drivers;
+  powerDef power_row_predecoder_blocks;
+  powerDef power_row_decoders;
+  powerDef power_bit_mux_predecoder_drivers;
+  powerDef power_bit_mux_predecoder_blocks;
+  powerDef power_bit_mux_decoders;
+  powerDef power_senseamp_mux_lev_1_predecoder_drivers;
+  powerDef power_senseamp_mux_lev_1_predecoder_blocks;
+  powerDef power_senseamp_mux_lev_1_decoders;
+  powerDef power_senseamp_mux_lev_2_predecoder_drivers;
+  powerDef power_senseamp_mux_lev_2_predecoder_blocks;
+  powerDef power_senseamp_mux_lev_2_decoders;
+  powerDef power_bitlines;
+  powerDef power_sense_amps;
+  powerDef power_prechg_eq_drivers;
+  powerDef power_output_drivers_at_subarray;
+  powerDef power_dataout_vertical_htree;
+  powerDef power_comparators;
+
+  powerDef power_cam_bitline_precharge_eq_drv;
+  powerDef power_searchline;
+  powerDef power_searchline_precharge;
+  powerDef power_matchlines;
+  powerDef power_matchline_precharge;
+  powerDef power_matchline_to_wordline_drv;
+
+  min_values_t arr_min;
+  enum Wire_type wt;
+
+  // dram stats
+  double activate_energy, read_energy, write_energy, precharge_energy,
+  refresh_power, leak_power_subbank_closed_page, leak_power_subbank_open_page,
+  leak_power_request_and_reply_networks;
+
+  double precharge_delay;
+
+  //Power-gating stats
+  double  array_leakage;
+  double  wl_leakage;
+  double  cl_leakage;
+
+  double sram_sleep_tx_width, wl_sleep_tx_width, cl_sleep_tx_width;
+  double sram_sleep_tx_area, wl_sleep_tx_area, cl_sleep_tx_area;
+  double sram_sleep_wakeup_latency, wl_sleep_wakeup_latency, cl_sleep_wakeup_latency, bl_floating_wakeup_latency;
+  double sram_sleep_wakeup_energy, wl_sleep_wakeup_energy, cl_sleep_wakeup_energy, bl_floating_wakeup_energy;
+
+  int num_active_mats;
+  int num_submarray_mats;
+
+  double long_channel_leakage_reduction_periperal;
+  double long_channel_leakage_reduction_memcell;
+
+  static bool lt(const mem_array * m1, const mem_array * m2);
+};
+
 class uca_org_t
 {
   public:
-    mem_array * tag_array2;
-    mem_array * data_array2;
+    mem_array tag_array2;
+    mem_array data_array2;
     double access_time;
     double cycle_time;
     double area;
@@ -569,108 +694,5 @@ uca_org_t cacti_interface(
     int REPEATERS_IN_HTREE_SEGMENTS_in,//TODO for now only wires with repeaters are supported
     int p_input);
 
-class mem_array
-{
-  public:
-  int    Ndcm;
-  int    Ndwl;
-  int    Ndbl;
-  double Nspd;
-  int    deg_bl_muxing;
-  int    Ndsam_lev_1;
-  int    Ndsam_lev_2;
-  double access_time;
-  double cycle_time;
-  double multisubbank_interleave_cycle_time;
-  double area_ram_cells;
-  double area;
-  powerDef power;
-  double delay_senseamp_mux_decoder;
-  double delay_before_subarray_output_driver;
-  double delay_from_subarray_output_driver_to_output;
-  double height;
-  double width;
-
-  double mat_height;
-  double mat_length;
-  double subarray_length;
-  double subarray_height;
-
-  double delay_route_to_bank,
-         delay_input_htree,
-         delay_row_predecode_driver_and_block,
-         delay_row_decoder,
-         delay_bitlines,
-         delay_sense_amp,
-         delay_subarray_output_driver,
-         delay_dout_htree,
-         delay_comparator,
-         delay_matchlines;
-
-  double all_banks_height,
-         all_banks_width,
-         area_efficiency;
-
-  powerDef power_routing_to_bank;
-  powerDef power_addr_input_htree;
-  powerDef power_data_input_htree;
-  powerDef power_data_output_htree;
-  powerDef power_htree_in_search;
-  powerDef power_htree_out_search;
-  powerDef power_row_predecoder_drivers;
-  powerDef power_row_predecoder_blocks;
-  powerDef power_row_decoders;
-  powerDef power_bit_mux_predecoder_drivers;
-  powerDef power_bit_mux_predecoder_blocks;
-  powerDef power_bit_mux_decoders;
-  powerDef power_senseamp_mux_lev_1_predecoder_drivers;
-  powerDef power_senseamp_mux_lev_1_predecoder_blocks;
-  powerDef power_senseamp_mux_lev_1_decoders;
-  powerDef power_senseamp_mux_lev_2_predecoder_drivers;
-  powerDef power_senseamp_mux_lev_2_predecoder_blocks;
-  powerDef power_senseamp_mux_lev_2_decoders;
-  powerDef power_bitlines;
-  powerDef power_sense_amps;
-  powerDef power_prechg_eq_drivers;
-  powerDef power_output_drivers_at_subarray;
-  powerDef power_dataout_vertical_htree;
-  powerDef power_comparators;
-
-  powerDef power_cam_bitline_precharge_eq_drv;
-  powerDef power_searchline;
-  powerDef power_searchline_precharge;
-  powerDef power_matchlines;
-  powerDef power_matchline_precharge;
-  powerDef power_matchline_to_wordline_drv;
-
-  min_values_t *arr_min;
-  enum Wire_type wt;
-
-  // dram stats
-  double activate_energy, read_energy, write_energy, precharge_energy,
-  refresh_power, leak_power_subbank_closed_page, leak_power_subbank_open_page,
-  leak_power_request_and_reply_networks;
-
-  double precharge_delay;
-
-  //Power-gating stats
-  double  array_leakage;
-  double  wl_leakage;
-  double  cl_leakage;
-
-  double sram_sleep_tx_width, wl_sleep_tx_width, cl_sleep_tx_width;
-  double sram_sleep_tx_area, wl_sleep_tx_area, cl_sleep_tx_area;
-  double sram_sleep_wakeup_latency, wl_sleep_wakeup_latency, cl_sleep_wakeup_latency, bl_floating_wakeup_latency;
-  double sram_sleep_wakeup_energy, wl_sleep_wakeup_energy, cl_sleep_wakeup_energy, bl_floating_wakeup_energy;
-
-  int num_active_mats;
-  int num_submarray_mats;
-
-  double long_channel_leakage_reduction_periperal;
-  double long_channel_leakage_reduction_memcell;
-
-  static bool lt(const mem_array * m1, const mem_array * m2);
-};
-
 
 #endif
diff --git a/cacti/io.cc b/cacti/io.cc
index a95d42b..5de7ce1 100644
--- a/cacti/io.cc
+++ b/cacti/io.cc
@@ -35,6 +35,9 @@
 #include <iostream>
 #include <sstream>
 #include <string.h>
+#ifdef ENABLE_CACHE
+#include <db.h>
+#endif
 
 #include "io.h"
 #include "area.h"
@@ -51,17 +54,17 @@ using namespace std;
 
 
 InputParameter::InputParameter()
-:  array_power_gated(false),
- bitline_floating(false),
- wl_power_gated(false),
- cl_power_gated(false),
- interconect_power_gated(false),
- power_gating(false),
- perfloss(0.01),
- cl_vertical (true),
- long_channel_device(false)
 {
 	dvs_voltage = std::vector<double>(0);
+
+   // Clear out all data used as the DB key, especially unused bits
+   // such that they're zero and not old data that might be different per run
+   size_t o1 = offsetof(InputParameter, first),
+          o2 = offsetof(InputParameter, last);
+   memset((char*)this + o1, 0, o2 - o1);
+
+  perfloss = 0.01;
+  cl_vertical = true;
 }
 
 /* Parses "cache.cfg" file */
@@ -1289,7 +1292,6 @@ uca_org_t cacti_interface(
 }
 
 
-
 bool InputParameter::error_checking()
 {
   int  A;
@@ -1731,22 +1733,22 @@ void output_data_csv(const uca_org_t & fin_res)
     file << g_ip->out_w << ", ";
     file << fin_res.access_time*1e+9 << ", ";
     file << fin_res.cycle_time*1e+9 << ", ";
-//    file << fin_res.data_array2->multisubbank_interleave_cycle_time*1e+9 << ", ";
-//    file << fin_res.data_array2->delay_request_network*1e+9 << ", ";
-//    file << fin_res.data_array2->delay_inside_mat*1e+9 <<  ", ";
+//    file << fin_res.data_array2.multisubbank_interleave_cycle_time*1e+9 << ", ";
+//    file << fin_res.data_array2.delay_request_network*1e+9 << ", ";
+//    file << fin_res.data_array2.delay_inside_mat*1e+9 <<  ", ";
 //    file << fin_res.data_array2.delay_reply_network*1e+9 << ", ";
 
 //    if (!(g_ip->fully_assoc || g_ip->pure_cam || g_ip->pure_ram))
 //        {
-//    	  file << fin_res.tag_array2->access_time*1e+9 << ", ";
+//    	  file << fin_res.tag_array2.access_time*1e+9 << ", ";
 //        }
 //    else
 //    {
 //    	file << 0 << ", ";
 //    }
-//    file << fin_res.data_array2->access_time*1e+9 << ", ";
-//    file << fin_res.data_array2->dram_refresh_period*1e+6 << ", ";
-//    file << fin_res.data_array2->dram_array_availability <<  ", ";
+//    file << fin_res.data_array2.access_time*1e+9 << ", ";
+//    file << fin_res.data_array2.dram_refresh_period*1e+6 << ", ";
+//    file << fin_res.data_array2.dram_array_availability <<  ", ";
     if (g_ip->fully_assoc || g_ip->pure_cam)
     {
     	file << fin_res.power.searchOp.dynamic*1e+9 << ", ";
@@ -1759,13 +1761,13 @@ void output_data_csv(const uca_org_t & fin_res)
     file << fin_res.power.writeOp.dynamic*1e+9 << ", ";
 //    if (!(g_ip->fully_assoc || g_ip->pure_cam || g_ip->pure_ram))
 //        {
-//        	file << fin_res.tag_array2->power.readOp.dynamic*1e+9 << ", ";
+//        	file << fin_res.tag_array2.power.readOp.dynamic*1e+9 << ", ";
 //        }
 //        	else
 //        {
 //        		file << "NA" << ", ";
 //        }
-//    file << fin_res.data_array2->power.readOp.dynamic*1e+9 << ", ";
+//    file << fin_res.data_array2.power.readOp.dynamic*1e+9 << ", ";
 //    if (g_ip->fully_assoc || g_ip->pure_cam)
 //        {
 //    	    file << fin_res.power.searchOp.dynamic*1000/fin_res.cycle_time << ", ";
@@ -1780,22 +1782,22 @@ void output_data_csv(const uca_org_t & fin_res)
 //    file << fin_res.data_array.refresh_power / fin_res.data_array.total_power.readOp.leakage << ", ";
     file << fin_res.area*1e-6 << ", ";
 
-    file << fin_res.data_array2->Ndwl << ", ";
-    file << fin_res.data_array2->Ndbl << ", ";
-    file << fin_res.data_array2->Nspd << ", ";
-    file << fin_res.data_array2->deg_bl_muxing << ", ";
-    file << fin_res.data_array2->Ndsam_lev_1 << ", ";
-    file << fin_res.data_array2->Ndsam_lev_2 << ", ";
-    file << fin_res.data_array2->area_efficiency << ", ";
+    file << fin_res.data_array2.Ndwl << ", ";
+    file << fin_res.data_array2.Ndbl << ", ";
+    file << fin_res.data_array2.Nspd << ", ";
+    file << fin_res.data_array2.deg_bl_muxing << ", ";
+    file << fin_res.data_array2.Ndsam_lev_1 << ", ";
+    file << fin_res.data_array2.Ndsam_lev_2 << ", ";
+    file << fin_res.data_array2.area_efficiency << ", ";
     if (!(g_ip->fully_assoc || g_ip->pure_cam || g_ip->pure_ram))
     {
-    file << fin_res.tag_array2->Ndwl << ", ";
-    file << fin_res.tag_array2->Ndbl << ", ";
-    file << fin_res.tag_array2->Nspd << ", ";
-    file << fin_res.tag_array2->deg_bl_muxing << ", ";
-    file << fin_res.tag_array2->Ndsam_lev_1 << ", ";
-    file << fin_res.tag_array2->Ndsam_lev_2 << ", ";
-    file << fin_res.tag_array2->area_efficiency << ", ";
+    file << fin_res.tag_array2.Ndwl << ", ";
+    file << fin_res.tag_array2.Ndbl << ", ";
+    file << fin_res.tag_array2.Nspd << ", ";
+    file << fin_res.tag_array2.deg_bl_muxing << ", ";
+    file << fin_res.tag_array2.Ndsam_lev_1 << ", ";
+    file << fin_res.tag_array2.Ndsam_lev_2 << ", ";
+    file << fin_res.tag_array2.area_efficiency << ", ";
     }
     else
     {
@@ -1839,8 +1841,8 @@ void output_data_csv(const uca_org_t & fin_res)
 void output_UCA(uca_org_t *fr)
 {
 
-double long_channel_leakage_reduction = 0.1 + 0.9*(0.8*fr->data_array2->long_channel_leakage_reduction_memcell
-														+ 0.2*fr->data_array2->long_channel_leakage_reduction_periperal);//TODO
+double long_channel_leakage_reduction = 0.1 + 0.9*(0.8*fr->data_array2.long_channel_leakage_reduction_memcell
+														+ 0.2*fr->data_array2.long_channel_leakage_reduction_periperal);//TODO
 double areaoverhead, overhead_data, overhead_tag;
 double wakeup_E, wakeup_T,  wakeup_E_data, wakeup_T_data,  wakeup_E_tag, wakeup_T_tag;
 int dvs_levels = g_ip->dvs_voltage.size();
@@ -1919,16 +1921,16 @@ bool dvs  = !g_ip->dvs_voltage.empty();
 		  }
   cout<< endl;
   if (g_ip->data_arr_ram_cell_tech_type >= 4) {
-    cout << "    Precharge Delay (ns): " << fr->data_array2->precharge_delay*1e9 << endl;
-    cout << "    Activate Energy (nJ): " << fr->data_array2->activate_energy*1e9 << endl;
-    cout << "    Read Energy (nJ): " << fr->data_array2->read_energy*1e9 << endl;
-    cout << "    Write Energy (nJ): " << fr->data_array2->write_energy*1e9 << endl;
-    cout << "    Precharge Energy (nJ): " << fr->data_array2->precharge_energy*1e9 << endl;
-    cout << "    Leakage Power Closed Page (mW): " << fr->data_array2->leak_power_subbank_closed_page*1e3 << endl;
-    cout << "    Leakage Power Open Page (mW): " << fr->data_array2->leak_power_subbank_open_page*1e3 << endl;
-    cout << "    Leakage Power I/O (mW): " << fr->data_array2->leak_power_request_and_reply_networks*1e3 << endl;
+    cout << "    Precharge Delay (ns): " << fr->data_array2.precharge_delay*1e9 << endl;
+    cout << "    Activate Energy (nJ): " << fr->data_array2.activate_energy*1e9 << endl;
+    cout << "    Read Energy (nJ): " << fr->data_array2.read_energy*1e9 << endl;
+    cout << "    Write Energy (nJ): " << fr->data_array2.write_energy*1e9 << endl;
+    cout << "    Precharge Energy (nJ): " << fr->data_array2.precharge_energy*1e9 << endl;
+    cout << "    Leakage Power Closed Page (mW): " << fr->data_array2.leak_power_subbank_closed_page*1e3 << endl;
+    cout << "    Leakage Power Open Page (mW): " << fr->data_array2.leak_power_subbank_open_page*1e3 << endl;
+    cout << "    Leakage Power I/O (mW): " << fr->data_array2.leak_power_request_and_reply_networks*1e3 << endl;
     cout << "    Refresh power (mW): " <<
-      fr->data_array2->refresh_power*1e3 << endl;
+      fr->data_array2.refresh_power*1e3 << endl;
   }
   else {
 	  if ((g_ip->fully_assoc|| g_ip->pure_cam))
@@ -2001,18 +2003,18 @@ bool dvs  = !g_ip->dvs_voltage.empty();
 	  areaoverhead = (fr->cache_ht*fr->cache_len/fr->uca_pg_reference->cache_ht/fr->uca_pg_reference->cache_len-1)*100;//%
 	  cout <<  "    \tPower gating circuits (sleep transistors) induced area overhead: " <<
 			  areaoverhead << " % " <<  endl ;
-	  wakeup_E = wakeup_E_data = fr->data_array2->sram_sleep_wakeup_energy
-			  + fr->data_array2->wl_sleep_wakeup_energy
-			  + fr->data_array2->bl_floating_wakeup_energy;
-	  wakeup_T = wakeup_T_data=MAX(fr->data_array2->sram_sleep_wakeup_latency,
-			  MAX(fr->data_array2->wl_sleep_wakeup_latency,fr->data_array2->bl_floating_wakeup_latency));
+	  wakeup_E = wakeup_E_data = fr->data_array2.sram_sleep_wakeup_energy
+			  + fr->data_array2.wl_sleep_wakeup_energy
+			  + fr->data_array2.bl_floating_wakeup_energy;
+	  wakeup_T = wakeup_T_data=MAX(fr->data_array2.sram_sleep_wakeup_latency,
+			  MAX(fr->data_array2.wl_sleep_wakeup_latency,fr->data_array2.bl_floating_wakeup_latency));
 	  if ((!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) && !g_ip->is_main_mem)
 	  {
-		  wakeup_E_tag = fr->tag_array2->sram_sleep_wakeup_energy
-				  + fr->tag_array2->wl_sleep_wakeup_energy
-				  + fr->tag_array2->bl_floating_wakeup_energy;
-		  wakeup_T_tag=MAX(fr->tag_array2->sram_sleep_wakeup_latency,
-				  MAX(fr->tag_array2->wl_sleep_wakeup_latency,fr->tag_array2->bl_floating_wakeup_latency));
+		  wakeup_E_tag = fr->tag_array2.sram_sleep_wakeup_energy
+				  + fr->tag_array2.wl_sleep_wakeup_energy
+				  + fr->tag_array2.bl_floating_wakeup_energy;
+		  wakeup_T_tag=MAX(fr->tag_array2.sram_sleep_wakeup_latency,
+				  MAX(fr->tag_array2.wl_sleep_wakeup_latency,fr->tag_array2.bl_floating_wakeup_latency));
 
 		  wakeup_E += wakeup_E_tag;
 		  wakeup_T = MAX(wakeup_T_tag, wakeup_T_data);
@@ -2024,24 +2026,24 @@ bool dvs  = !g_ip->dvs_voltage.empty();
 			  wakeup_E*1e9 << endl ;
   }
   cout <<endl << endl;
-  cout << "    Best Ndwl : " << fr->data_array2->Ndwl << endl;
-  cout << "    Best Ndbl : " << fr->data_array2->Ndbl << endl;
-  cout << "    Best Nspd : " << fr->data_array2->Nspd << endl;
-  cout << "    Best Ndcm : " << fr->data_array2->deg_bl_muxing << endl;
-  cout << "    Best Ndsam L1 : " << fr->data_array2->Ndsam_lev_1 << endl;
-  cout << "    Best Ndsam L2 : " << fr->data_array2->Ndsam_lev_2 << endl << endl;
+  cout << "    Best Ndwl : " << fr->data_array2.Ndwl << endl;
+  cout << "    Best Ndbl : " << fr->data_array2.Ndbl << endl;
+  cout << "    Best Nspd : " << fr->data_array2.Nspd << endl;
+  cout << "    Best Ndcm : " << fr->data_array2.deg_bl_muxing << endl;
+  cout << "    Best Ndsam L1 : " << fr->data_array2.Ndsam_lev_1 << endl;
+  cout << "    Best Ndsam L2 : " << fr->data_array2.Ndsam_lev_2 << endl << endl;
 
   if ((!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) && !g_ip->is_main_mem)
   {
-    cout << "    Best Ntwl : " << fr->tag_array2->Ndwl << endl;
-    cout << "    Best Ntbl : " << fr->tag_array2->Ndbl << endl;
-    cout << "    Best Ntspd : " << fr->tag_array2->Nspd << endl;
-    cout << "    Best Ntcm : " << fr->tag_array2->deg_bl_muxing << endl;
-    cout << "    Best Ntsam L1 : " << fr->tag_array2->Ndsam_lev_1 << endl;
-    cout << "    Best Ntsam L2 : " << fr->tag_array2->Ndsam_lev_2 << endl;
+    cout << "    Best Ntwl : " << fr->tag_array2.Ndwl << endl;
+    cout << "    Best Ntbl : " << fr->tag_array2.Ndbl << endl;
+    cout << "    Best Ntspd : " << fr->tag_array2.Nspd << endl;
+    cout << "    Best Ntcm : " << fr->tag_array2.deg_bl_muxing << endl;
+    cout << "    Best Ntsam L1 : " << fr->tag_array2.Ndsam_lev_1 << endl;
+    cout << "    Best Ntsam L2 : " << fr->tag_array2.Ndsam_lev_2 << endl;
   }
 
-  switch (fr->data_array2->wt) {
+  switch (fr->data_array2.wt) {
     case (0):
       cout <<  "    Data array, H-tree wire type: Delay optimized global wires\n";
       break;
@@ -2061,12 +2063,12 @@ bool dvs  = !g_ip->dvs_voltage.empty();
       cout <<  "    Data array, wire type: Low swing wires\n";
       break;
     default:
-      cout << "ERROR - Unknown wire type " << (int) fr->data_array2->wt <<endl;
+      cout << "ERROR - Unknown wire type " << (int) fr->data_array2.wt <<endl;
       exit(0);
   }
 
   if (!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) {
-    switch (fr->tag_array2->wt) {
+    switch (fr->tag_array2.wt) {
       case (0):
         cout <<  "    Tag array, H-tree wire type: Delay optimized global wires\n";
         break;
@@ -2086,7 +2088,7 @@ bool dvs  = !g_ip->dvs_voltage.empty();
         cout <<  "    Tag array, wire type: Low swing wires\n";
         break;
       default:
-        cout << "ERROR - Unknown wire type " << (int) fr->tag_array2->wt <<endl;
+        cout << "ERROR - Unknown wire type " << (int) fr->tag_array2.wt <<endl;
         exit(-1);
     }
   }
@@ -2103,18 +2105,18 @@ if(0){ //detailed power-gating output
 		  areaoverhead = fr->cache_ht*fr->cache_len/fr->uca_pg_reference->cache_ht/fr->uca_pg_reference->cache_len-1;
 		  cout <<  "    Power gating circuits (sleep transistors) induced area overhead: " <<
 		  	  			  areaoverhead << " % " <<  endl ;
-		  wakeup_E = wakeup_E_data = fr->data_array2->sram_sleep_wakeup_energy
-				     + fr->data_array2->wl_sleep_wakeup_energy
-				     + fr->data_array2->bl_floating_wakeup_energy;
-		  wakeup_T = wakeup_T_data=MAX(fr->data_array2->sram_sleep_wakeup_latency,
-				  MAX(fr->data_array2->wl_sleep_wakeup_latency,fr->data_array2->bl_floating_wakeup_latency));
+		  wakeup_E = wakeup_E_data = fr->data_array2.sram_sleep_wakeup_energy
+				     + fr->data_array2.wl_sleep_wakeup_energy
+				     + fr->data_array2.bl_floating_wakeup_energy;
+		  wakeup_T = wakeup_T_data=MAX(fr->data_array2.sram_sleep_wakeup_latency,
+				  MAX(fr->data_array2.wl_sleep_wakeup_latency,fr->data_array2.bl_floating_wakeup_latency));
 		  if ((!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) && !g_ip->is_main_mem)
 		  {
-			  wakeup_E_tag = fr->tag_array2->sram_sleep_wakeup_energy
-					     + fr->tag_array2->wl_sleep_wakeup_energy
-					     + fr->tag_array2->bl_floating_wakeup_energy;
-			  wakeup_T_tag=MAX(fr->tag_array2->sram_sleep_wakeup_latency,
-					  MAX(fr->tag_array2->wl_sleep_wakeup_latency,fr->tag_array2->bl_floating_wakeup_latency));
+			  wakeup_E_tag = fr->tag_array2.sram_sleep_wakeup_energy
+					     + fr->tag_array2.wl_sleep_wakeup_energy
+					     + fr->tag_array2.bl_floating_wakeup_energy;
+			  wakeup_T_tag=MAX(fr->tag_array2.sram_sleep_wakeup_latency,
+					  MAX(fr->tag_array2.wl_sleep_wakeup_latency,fr->tag_array2.bl_floating_wakeup_latency));
 
 			  wakeup_E += wakeup_E_tag;
 			  wakeup_T = MAX(wakeup_T_tag, wakeup_T_data);
@@ -2135,95 +2137,95 @@ if(0){ //detailed power-gating output
 			  cout <<  "  Fully associative cache array: " << endl;
 
 		  cout <<  "\t Sub-array Sleep Tx size (um) - " <<
-		  fr->data_array2->sram_sleep_tx_width << endl;
+		  fr->data_array2.sram_sleep_tx_width << endl;
 
 		  //    cout <<  "\t Sub-array Sleep Tx total size (um) - " <<
-		  //      fr->data_array2->sram_sleep_tx_width << endl;
+		  //      fr->data_array2.sram_sleep_tx_width << endl;
 
 		  cout <<  "\t Sub-array Sleep Tx total area (mm^2) - " <<
-		  fr->data_array2->sram_sleep_tx_area*1e-6 << endl;
+		  fr->data_array2.sram_sleep_tx_area*1e-6 << endl;
 
 		  cout <<  "\t Sub-array wakeup time (ns) - " <<
-		  fr->data_array2->sram_sleep_wakeup_latency*1e9 << endl;
+		  fr->data_array2.sram_sleep_wakeup_latency*1e9 << endl;
 
 		  cout <<  "\t Sub-array Tx energy (nJ) - " <<
-		  fr->data_array2->sram_sleep_wakeup_energy*1e9 << endl;
+		  fr->data_array2.sram_sleep_wakeup_energy*1e9 << endl;
 		  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 		  cout << endl;
 		  cout <<  "\t WL Sleep Tx size (um) - " <<
-		  fr->data_array2->wl_sleep_tx_width << endl;
+		  fr->data_array2.wl_sleep_tx_width << endl;
 
 		  //    cout <<  "\t WL Sleep total Tx size (um) - " <<
-		  //      fr->data_array2->wl_sleep_tx_width << endl;
+		  //      fr->data_array2.wl_sleep_tx_width << endl;
 
 		  cout <<  "\t WL Sleep Tx total area (mm^2) - " <<
-		  fr->data_array2->wl_sleep_tx_area*1e-6 << endl;
+		  fr->data_array2.wl_sleep_tx_area*1e-6 << endl;
 
 		  cout <<  "\t WL wakeup time (ns) - " <<
-		  fr->data_array2->wl_sleep_wakeup_latency*1e9 << endl;
+		  fr->data_array2.wl_sleep_wakeup_latency*1e9 << endl;
 
 		  cout <<  "\t WL Tx energy (nJ) - " <<
-		  fr->data_array2->wl_sleep_wakeup_energy*1e9 << endl;
+		  fr->data_array2.wl_sleep_wakeup_energy*1e9 << endl;
 		  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 		  cout << endl;
 		  cout <<  "\t BL floating wakeup time (ns) - " <<
-		  fr->data_array2->bl_floating_wakeup_latency*1e9 << endl;
+		  fr->data_array2.bl_floating_wakeup_latency*1e9 << endl;
 
 		  cout <<  "\t BL floating Tx energy (nJ) - " <<
-		  fr->data_array2->bl_floating_wakeup_energy*1e9 << endl;
+		  fr->data_array2.bl_floating_wakeup_energy*1e9 << endl;
 		  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 		  cout << endl;
 
-		  cout <<  "\t Active mats per access - " << fr->data_array2->num_active_mats<<endl;
-		  cout <<  "\t Active subarrays per mat - " << fr->data_array2->num_submarray_mats<<endl;
+		  cout <<  "\t Active mats per access - " << fr->data_array2.num_active_mats<<endl;
+		  cout <<  "\t Active subarrays per mat - " << fr->data_array2.num_submarray_mats<<endl;
 		  cout << endl;
 		  /* Tag array area stats */
 		  if ((!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) && !g_ip->is_main_mem)
 		  {
 			  cout <<  "  Tag array: " << endl;
 			  cout <<  "\t Sub-array Sleep Tx size (um) - " <<
-			  fr->tag_array2->sram_sleep_tx_width << endl;
+			  fr->tag_array2.sram_sleep_tx_width << endl;
 
 			  //    cout <<  "\t Sub-array Sleep Tx total size (um) - " <<
-			  //      fr->tag_array2->sram_sleep_tx_width << endl;
+			  //      fr->tag_array2.sram_sleep_tx_width << endl;
 
 			  cout <<  "\t Sub-array Sleep Tx total area (mm^2) - " <<
-			  fr->tag_array2->sram_sleep_tx_area*1e-6 << endl;
+			  fr->tag_array2.sram_sleep_tx_area*1e-6 << endl;
 
 			  cout <<  "\t Sub-array wakeup time (ns) - " <<
-			  fr->tag_array2->sram_sleep_wakeup_latency*1e9 << endl;
+			  fr->tag_array2.sram_sleep_wakeup_latency*1e9 << endl;
 
 			  cout <<  "\t Sub-array Tx energy (nJ) - " <<
-			  fr->tag_array2->sram_sleep_wakeup_energy*1e9 << endl;
+			  fr->tag_array2.sram_sleep_wakeup_energy*1e9 << endl;
 			  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 			  cout << endl;
 			  cout <<  "\t WL Sleep Tx size (um) - " <<
-			  fr->tag_array2->wl_sleep_tx_width << endl;
+			  fr->tag_array2.wl_sleep_tx_width << endl;
 
 			  //    cout <<  "\t WL Sleep total Tx size (um) - " <<
-			  //      fr->tag_array2->wl_sleep_tx_width << endl;
+			  //      fr->tag_array2.wl_sleep_tx_width << endl;
 
 			  cout <<  "\t WL Sleep Tx total area (mm^2) - " <<
-			  fr->tag_array2->wl_sleep_tx_area*1e-6 << endl;
+			  fr->tag_array2.wl_sleep_tx_area*1e-6 << endl;
 
 			  cout <<  "\t WL wakeup time (ns) - " <<
-			  fr->tag_array2->wl_sleep_wakeup_latency*1e9 << endl;
+			  fr->tag_array2.wl_sleep_wakeup_latency*1e9 << endl;
 
 			  cout <<  "\t WL Tx energy (nJ) - " <<
-			  fr->tag_array2->wl_sleep_wakeup_energy*1e9 << endl;
+			  fr->tag_array2.wl_sleep_wakeup_energy*1e9 << endl;
 			  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 			  cout << endl;
 			  cout <<  "\t BL floating wakeup time (ns) - " <<
-			  fr->tag_array2->bl_floating_wakeup_latency*1e9 << endl;
+			  fr->tag_array2.bl_floating_wakeup_latency*1e9 << endl;
 
 			  cout <<  "\t BL floating Tx energy (nJ) - " <<
-			  fr->tag_array2->bl_floating_wakeup_energy*1e9 << endl;
+			  fr->tag_array2.bl_floating_wakeup_energy*1e9 << endl;
 			  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 			  cout << endl;
 
-			  cout <<  "\t Active mats per access - " << fr->tag_array2->num_active_mats<<endl;
-			  cout <<  "\t Active subarrays per mat - " << fr->tag_array2->num_submarray_mats<<endl;
+			  cout <<  "\t Active mats per access - " << fr->tag_array2.num_active_mats<<endl;
+			  cout <<  "\t Active subarrays per mat - " << fr->tag_array2.num_submarray_mats<<endl;
 			  cout << endl;
 		  }
 }
@@ -2233,92 +2235,92 @@ if(0){ //detailed power-gating output
     cout << endl << "Time Components:" << endl << endl;
 
     cout << "  Data side (with Output driver) (ns): " <<
-    		fr->data_array2->access_time/1e-9;
+    		fr->data_array2.access_time/1e-9;
     if (dvs)
     {
     	cout<<" (@DVS_Level0); ";
     	for (i = 0; i<dvs_levels; i++)
-    		cout<<fr->uca_q[i]->data_array2->access_time/1e-9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+    		cout<<fr->uca_q[i]->data_array2.access_time/1e-9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
     }
     cout<< endl;
 
     cout <<  "\tH-tree delay outside banks (ns): " <<
-      fr->data_array2->delay_route_to_bank * 1e9 ;
+      fr->data_array2.delay_route_to_bank * 1e9 ;
     if (dvs)
     {
     	cout<<" (@DVS_Level0); ";
     	for (i = 0; i<dvs_levels; i++)
-    		cout<<fr->uca_q[i]->data_array2->delay_route_to_bank * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+    		cout<<fr->uca_q[i]->data_array2.delay_route_to_bank * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
     }
     cout<< endl;
 
     cout <<  "\tH-tree input delay (inside a bank) (ns): " <<
-      fr->data_array2->delay_input_htree * 1e9 ;
+      fr->data_array2.delay_input_htree * 1e9 ;
     if (dvs)
     {
     	cout<<" (@DVS_Level0); ";
     	for (i = 0; i<dvs_levels; i++)
-    		cout<<fr->uca_q[i]->data_array2->delay_input_htree * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+    		cout<<fr->uca_q[i]->data_array2.delay_input_htree * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
     }
     cout<< endl;
 
     if (!(g_ip->pure_cam || g_ip->fully_assoc))
     {
       cout <<  "\tDecoder + wordline delay (ns): " <<
-        fr->data_array2->delay_row_predecode_driver_and_block * 1e9 +
-        fr->data_array2->delay_row_decoder * 1e9;
+        fr->data_array2.delay_row_predecode_driver_and_block * 1e9 +
+        fr->data_array2.delay_row_decoder * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->data_array2->delay_row_predecode_driver_and_block * 1e9 +
-      		fr->uca_q[i]->data_array2->delay_row_decoder * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->data_array2.delay_row_predecode_driver_and_block * 1e9 +
+      		fr->uca_q[i]->data_array2.delay_row_decoder * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
     }
     else
     {
         cout <<  "\tCAM search delay (ns): " <<
-          fr->data_array2->delay_matchlines * 1e9;
+          fr->data_array2.delay_matchlines * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->delay_matchlines * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.delay_matchlines * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
     }
 
     cout <<  "\tBitline delay (ns): " <<
-      fr->data_array2->delay_bitlines/1e-9 ;
+      fr->data_array2.delay_bitlines/1e-9 ;
     if (dvs)
     {
     	cout<<" (@DVS_Level0); ";
     	for (i = 0; i<dvs_levels; i++)
-    		cout<<fr->uca_q[i]->data_array2->delay_bitlines/1e-9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+    		cout<<fr->uca_q[i]->data_array2.delay_bitlines/1e-9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
     }
     cout<< endl;
 
     cout <<  "\tSense Amplifier delay (ns): " <<
-      fr->data_array2->delay_sense_amp * 1e9 ;
+      fr->data_array2.delay_sense_amp * 1e9 ;
     if (dvs)
     {
     	cout<<" (@DVS_Level0); ";
     	for (i = 0; i<dvs_levels; i++)
-    		cout<<fr->uca_q[i]->data_array2->delay_sense_amp*1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+    		cout<<fr->uca_q[i]->data_array2.delay_sense_amp*1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
     }
     cout<< endl;
 
 
     cout <<  "\tH-tree output delay (inside a bank) (ns): " <<
-      fr->data_array2->delay_subarray_output_driver * 1e9 +
-      fr->data_array2->delay_dout_htree * 1e9;
+      fr->data_array2.delay_subarray_output_driver * 1e9 +
+      fr->data_array2.delay_dout_htree * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->data_array2->delay_subarray_output_driver * 1e9 +
-      		fr->uca_q[i]->data_array2->delay_dout_htree * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->data_array2.delay_subarray_output_driver * 1e9 +
+      		fr->uca_q[i]->data_array2.delay_dout_htree * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
     cout<< endl;
     if (g_ip->power_gating)
@@ -2331,85 +2333,85 @@ if(0){ //detailed power-gating output
     {
       /* tag array stats */
       cout << endl << "  Tag side (with Output driver) (ns): " <<
-        fr->tag_array2->access_time/1e-9 ;
+        fr->tag_array2.access_time/1e-9 ;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->access_time/1e-9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.access_time/1e-9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout << endl;
       cout <<  "\tH-tree delay outside banks (ns): " <<
-        fr->tag_array2->delay_route_to_bank * 1e9;
+        fr->tag_array2.delay_route_to_bank * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->delay_route_to_bank * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.delay_route_to_bank * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout << endl;
 
       cout <<  "\tH-tree input delay (inside a bank) (ns): " <<
-        fr->tag_array2->delay_input_htree * 1e9;
+        fr->tag_array2.delay_input_htree * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->delay_input_htree * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.delay_input_htree * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout << endl;
 
       cout <<  "\tDecoder + wordline delay (ns): " <<
-        fr->tag_array2->delay_row_predecode_driver_and_block * 1e9 +
-        fr->tag_array2->delay_row_decoder * 1e9;
+        fr->tag_array2.delay_row_predecode_driver_and_block * 1e9 +
+        fr->tag_array2.delay_row_decoder * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->delay_row_predecode_driver_and_block * 1e9 +
-            fr->uca_q[i]->tag_array2->delay_row_decoder * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.delay_row_predecode_driver_and_block * 1e9 +
+            fr->uca_q[i]->tag_array2.delay_row_decoder * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout << endl;
 
       cout <<  "\tBitline delay (ns): " <<
-        fr->tag_array2->delay_bitlines/1e-9;
+        fr->tag_array2.delay_bitlines/1e-9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->delay_bitlines * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.delay_bitlines * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout << endl;
 
       cout <<  "\tSense Amplifier delay (ns): " <<
-        fr->tag_array2->delay_sense_amp * 1e9 ;
+        fr->tag_array2.delay_sense_amp * 1e9 ;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->delay_sense_amp * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.delay_sense_amp * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout << endl;
 
       cout <<  "\tComparator delay (ns): " <<
-        fr->tag_array2->delay_comparator * 1e9;
+        fr->tag_array2.delay_comparator * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->delay_comparator * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.delay_comparator * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout << endl;
 
       cout <<  "\tH-tree output delay (inside a bank) (ns): " <<
-        fr->tag_array2->delay_subarray_output_driver * 1e9 +
-        fr->tag_array2->delay_dout_htree * 1e9 ;
+        fr->tag_array2.delay_subarray_output_driver * 1e9 +
+        fr->tag_array2.delay_dout_htree * 1e9 ;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->delay_subarray_output_driver * 1e9 +
-            fr->uca_q[i]->tag_array2->delay_dout_htree * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.delay_subarray_output_driver * 1e9 +
+            fr->uca_q[i]->tag_array2.delay_dout_htree * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout << endl;
       if (g_ip->power_gating)
@@ -2427,29 +2429,29 @@ if(0){ //detailed power-gating output
     if (!(g_ip->pure_cam || g_ip->fully_assoc))
     {
     	cout << "  Data array: Total dynamic read energy/access  (nJ): " <<
-    			fr->data_array2->power.readOp.dynamic * 1e9;
+    			fr->data_array2.power.readOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power.readOp.dynamic * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power.readOp.dynamic * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	if (g_ip->power_gating)
     	{
     		cout << "\tTotal leakage power of a bank, power gated with retaining memory content, including its network outside (mW): " <<
-    				(g_ip->long_channel_device ? fr->data_array2->power.readOp.power_gated_leakage*long_channel_leakage_reduction : fr->data_array2->power.readOp.power_gated_leakage)*1e3 << endl;
+    				(g_ip->long_channel_device ? fr->data_array2.power.readOp.power_gated_leakage*long_channel_leakage_reduction : fr->data_array2.power.readOp.power_gated_leakage)*1e3 << endl;
     	}
 //    	else
 //    	{
     		cout << "\tTotal leakage power of a bank without power gating, including its network outside (mW): " <<
-    				(g_ip->long_channel_device ? fr->data_array2->power.readOp.leakage*long_channel_leakage_reduction : fr->data_array2->power.readOp.leakage)*1e3;
+    				(g_ip->long_channel_device ? fr->data_array2.power.readOp.leakage*long_channel_leakage_reduction : fr->data_array2.power.readOp.leakage)*1e3;
             if (dvs)
             {
             	cout<<" (@DVS_Level0); ";
             	for (i = 0; i<dvs_levels; i++)
-            		cout<< (g_ip->long_channel_device ?fr->uca_q[i]->data_array2->power.readOp.leakage*long_channel_leakage_reduction : fr->uca_q[i]->data_array2->power.readOp.leakage) * 1e3 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+            		cout<< (g_ip->long_channel_device ?fr->uca_q[i]->data_array2.power.readOp.leakage*long_channel_leakage_reduction : fr->uca_q[i]->data_array2.power.readOp.leakage) * 1e3 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
             }
             cout<< endl;
 
@@ -2457,131 +2459,131 @@ if(0){ //detailed power-gating output
 
     	cout << "\tTotal energy in H-tree outside banks (that includes both "
     			"address and data transfer) (nJ): " <<
-    			(fr->data_array2->power_routing_to_bank.readOp.dynamic) * 1e9 ;
+    			(fr->data_array2.power_routing_to_bank.readOp.dynamic) * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_routing_to_bank.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_routing_to_bank.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout << "\tInput H-tree inside bank Energy (nJ): " <<
-    			(fr->data_array2->power_addr_input_htree.readOp.dynamic) * 1e9 ;
+    			(fr->data_array2.power_addr_input_htree.readOp.dynamic) * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_addr_input_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_addr_input_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
 
     	cout << "\tOutput Htree inside bank Energy (nJ): " <<
-    			fr->data_array2->power_data_output_htree.readOp.dynamic * 1e9 ;
+    			fr->data_array2.power_data_output_htree.readOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_data_output_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_data_output_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tDecoder (nJ): " <<
-    			fr->data_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9 ;
+    			fr->data_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<(fr->uca_q[i]->data_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
-    			       fr->uca_q[i]->data_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9) <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<(fr->uca_q[i]->data_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+    			       fr->uca_q[i]->data_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9) <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tWordline (nJ): " <<
-    			fr->data_array2->power_row_decoders.readOp.dynamic * 1e9;
+    			fr->data_array2.power_row_decoders.readOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_row_decoders.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_row_decoders.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tBitline mux & associated drivers (nJ): " <<
-    			fr->data_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_bit_mux_decoders.readOp.dynamic * 1e9;
+    			fr->data_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_bit_mux_decoders.readOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<(fr->uca_q[i]->data_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_bit_mux_decoders.readOp.dynamic * 1e9)
+        		cout<<(fr->uca_q[i]->data_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_bit_mux_decoders.readOp.dynamic * 1e9)
             			<<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tSense amp mux & associated drivers (nJ): " <<
-    			fr->data_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
-    			fr->data_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9;
+    			fr->data_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+    			fr->data_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<( fr->uca_q[i]->data_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
-            			fr->uca_q[i]->data_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9)
+        		cout<<( fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9)
             			<<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tBitlines precharge and equalization circuit (nJ): " <<
-    			fr->data_array2->power_prechg_eq_drivers.readOp.dynamic * 1e9;
+    			fr->data_array2.power_prechg_eq_drivers.readOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_prechg_eq_drivers.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_prechg_eq_drivers.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tBitlines (nJ): " <<
-    			fr->data_array2->power_bitlines.readOp.dynamic * 1e9 ;
+    			fr->data_array2.power_bitlines.readOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_bitlines.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_bitlines.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tSense amplifier energy (nJ): " <<
-    			fr->data_array2->power_sense_amps.readOp.dynamic * 1e9 ;
+    			fr->data_array2.power_sense_amps.readOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_sense_amps.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_sense_amps.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tSub-array output driver (nJ): " <<
-    			fr->data_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 ;
+    			fr->data_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
@@ -2590,40 +2592,40 @@ if(0){ //detailed power-gating output
     	{
     		cout << "\tTotal leakage power in H-tree outside a bank when power gated (that includes both "
     				"address and data network) ((mW)): " <<
-    				(g_ip->long_channel_device?fr->data_array2->power_routing_to_bank.readOp.power_gated_leakage * long_channel_leakage_reduction: fr->data_array2->power_routing_to_bank.readOp.power_gated_leakage) * 1e3 << endl;
+    				(g_ip->long_channel_device?fr->data_array2.power_routing_to_bank.readOp.power_gated_leakage * long_channel_leakage_reduction: fr->data_array2.power_routing_to_bank.readOp.power_gated_leakage) * 1e3 << endl;
     	}
 //    	else
 //    	{
     		cout << "\tTotal leakage power in H-tree outside a bank (that includes both "
     				"address and data network) ((mW)): " <<
-    				(g_ip->long_channel_device? fr->data_array2->power_routing_to_bank.readOp.leakage * long_channel_leakage_reduction: fr->data_array2->power_routing_to_bank.readOp.leakage) * 1e3 ;
+    				(g_ip->long_channel_device? fr->data_array2.power_routing_to_bank.readOp.leakage * long_channel_leakage_reduction: fr->data_array2.power_routing_to_bank.readOp.leakage) * 1e3 ;
             if (dvs)
             {
             	cout<<" (@DVS_Level0); ";
             	for (i = 0; i<dvs_levels; i++)
-            		cout<<(g_ip->long_channel_device? fr->uca_q[i]->data_array2->power_routing_to_bank.readOp.leakage* long_channel_leakage_reduction: fr->uca_q[i]->data_array2->power_routing_to_bank.readOp.leakage) * 1e3 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+            		cout<<(g_ip->long_channel_device? fr->uca_q[i]->data_array2.power_routing_to_bank.readOp.leakage* long_channel_leakage_reduction: fr->uca_q[i]->data_array2.power_routing_to_bank.readOp.leakage) * 1e3 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
             }
             cout<< endl;
 
 //    	}
     	//    	cout << "\tTotal leakage power in H-tree (that includes both "
     	//    	      "address and data network) ((mW)): " <<
-    	//    	        (fr->data_array2->power_addr_input_htree.readOp.leakage +
-    	//    	         fr->data_array2->power_data_output_htree.readOp.leakage +
-    	//    	         fr->data_array2->power_routing_to_bank.readOp.leakage) * 1e3 << endl;
+    	//    	        (fr->data_array2.power_addr_input_htree.readOp.leakage +
+    	//    	         fr->data_array2.power_data_output_htree.readOp.leakage +
+    	//    	         fr->data_array2.power_routing_to_bank.readOp.leakage) * 1e3 << endl;
 
     	//    	cout << "\tTotal leakage power in cells (mW): " <<
-    	//    	        (fr->data_array2->array_leakage) * 1e3 << endl;
+    	//    	        (fr->data_array2.array_leakage) * 1e3 << endl;
     	//    	cout << "\tTotal leakage power in row logic(mW): " <<
-    	//    	        (fr->data_array2->wl_leakage) * 1e3 << endl;
+    	//    	        (fr->data_array2.wl_leakage) * 1e3 << endl;
     	//    	cout << "\tTotal leakage power in column logic(mW): " <<
-    	//    	        (fr->data_array2->cl_leakage) * 1e3 << endl;
+    	//    	        (fr->data_array2.cl_leakage) * 1e3 << endl;
     	//
     	//    	cout << "\tTotal gate leakage power in H-tree (that includes both "
     	//    	      "address and data network) ((mW)): " <<
-    	//    	        (fr->data_array2->power_addr_input_htree.readOp.gate_leakage +
-    	//    	         fr->data_array2->power_data_output_htree.readOp.gate_leakage +
-    	//    	         fr->data_array2->power_routing_to_bank.readOp.gate_leakage) * 1e3 << endl;
+    	//    	        (fr->data_array2.power_addr_input_htree.readOp.gate_leakage +
+    	//    	         fr->data_array2.power_data_output_htree.readOp.gate_leakage +
+    	//    	         fr->data_array2.power_routing_to_bank.readOp.gate_leakage) * 1e3 << endl;
     }
 
     if (g_ip->pure_cam||g_ip->fully_assoc)
@@ -2631,316 +2633,316 @@ if(0){ //detailed power-gating output
 
     	if (g_ip->pure_cam) cout << "  CAM array:"<<endl;
     	//            	cout << "  Total dynamic associative search energy/access  (nJ): " <<
-    	//                      fr->data_array2->power.searchOp.dynamic * 1e9 << endl;
+    	//                      fr->data_array2.power.searchOp.dynamic * 1e9 << endl;
     	//    	        cout << "\tTotal energy in H-tree (that includes both "
     	//    	            	      "match key and data transfer) (nJ): " <<
-    	//    	              (fr->data_array2->power_htree_in_search.searchOp.dynamic +
-    	//    	               fr->data_array2->power_htree_out_search.searchOp.dynamic +
-    	//    	               fr->data_array2->power_routing_to_bank.searchOp.dynamic) * 1e9 << endl;
+    	//    	              (fr->data_array2.power_htree_in_search.searchOp.dynamic +
+    	//    	               fr->data_array2.power_htree_out_search.searchOp.dynamic +
+    	//    	               fr->data_array2.power_routing_to_bank.searchOp.dynamic) * 1e9 << endl;
     	//    	        cout << "\tKeyword input and result output Htrees inside bank Energy (nJ): " <<
-    	//    	              (fr->data_array2->power_htree_in_search.searchOp.dynamic +
-    	//    	       	               fr->data_array2->power_htree_out_search.searchOp.dynamic) * 1e9 << endl;
+    	//    	              (fr->data_array2.power_htree_in_search.searchOp.dynamic +
+    	//    	       	               fr->data_array2.power_htree_out_search.searchOp.dynamic) * 1e9 << endl;
     	//    	        cout <<  "\tSearchlines (nJ): " <<
-    	//    	          	   fr->data_array2->power_searchline.searchOp.dynamic * 1e9 +
-    	//    	          	   fr->data_array2->power_searchline_precharge.searchOp.dynamic * 1e9 << endl;
+    	//    	          	   fr->data_array2.power_searchline.searchOp.dynamic * 1e9 +
+    	//    	          	   fr->data_array2.power_searchline_precharge.searchOp.dynamic * 1e9 << endl;
     	//    	        cout <<  "\tMatchlines  (nJ): " <<
-    	//    	               fr->data_array2->power_matchlines.searchOp.dynamic * 1e9 +
-    	//    	        	   fr->data_array2->power_matchline_precharge.searchOp.dynamic * 1e9 << endl;
+    	//    	               fr->data_array2.power_matchlines.searchOp.dynamic * 1e9 +
+    	//    	        	   fr->data_array2.power_matchline_precharge.searchOp.dynamic * 1e9 << endl;
     	//    	        cout <<  "\tSub-array output driver (nJ): " <<
-    	//    	          	   fr->data_array2->power_output_drivers_at_subarray.searchOp.dynamic * 1e9 << endl;
+    	//    	          	   fr->data_array2.power_output_drivers_at_subarray.searchOp.dynamic * 1e9 << endl;
     	//
     	//
     	//            	cout <<endl<< "  Total dynamic read energy/access  (nJ): " <<
-    	//            	      fr->data_array2->power.readOp.dynamic * 1e9 << endl;
+    	//            	      fr->data_array2.power.readOp.dynamic * 1e9 << endl;
     	//    	        cout << "\tTotal energy in H-tree (that includes both "
     	//    	            	      "address and data transfer) (nJ): " <<
-    	//    	              (fr->data_array2->power_addr_input_htree.readOp.dynamic +
-    	//    	               fr->data_array2->power_data_output_htree.readOp.dynamic +
-    	//    	               fr->data_array2->power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
+    	//    	              (fr->data_array2.power_addr_input_htree.readOp.dynamic +
+    	//    	               fr->data_array2.power_data_output_htree.readOp.dynamic +
+    	//    	               fr->data_array2.power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
     	//    	        cout << "\tOutput Htree inside bank Energy (nJ): " <<
-    	//    	          	   fr->data_array2->power_data_output_htree.readOp.dynamic * 1e9 << endl;
+    	//    	          	   fr->data_array2.power_data_output_htree.readOp.dynamic * 1e9 << endl;
     	//    	        cout <<  "\tDecoder (nJ): " <<
-    	//    	          	   fr->data_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
-    	//    	          	   fr->data_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9 << endl;
+    	//    	          	   fr->data_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+    	//    	          	   fr->data_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9 << endl;
     	//    	        cout <<  "\tWordline (nJ): " <<
-    	//    	          	   fr->data_array2->power_row_decoders.readOp.dynamic * 1e9 << endl;
+    	//    	          	   fr->data_array2.power_row_decoders.readOp.dynamic * 1e9 << endl;
     	//    	        cout <<  "\tBitline mux & associated drivers (nJ): " <<
-    	//    	          	   fr->data_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
-    	//    	          	   fr->data_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
-    	//    	           	   fr->data_array2->power_bit_mux_decoders.readOp.dynamic * 1e9 << endl;
+    	//    	          	   fr->data_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+    	//    	          	   fr->data_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+    	//    	           	   fr->data_array2.power_bit_mux_decoders.readOp.dynamic * 1e9 << endl;
     	//    	        cout <<  "\tSense amp mux & associated drivers (nJ): " <<
-    	//    	         	   fr->data_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
-    	//    	          	   fr->data_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
-    	//    	          	   fr->data_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
-    	//    	           	   fr->data_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
-    	//    	           	   fr->data_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
-    	//    	          	   fr->data_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << endl;
+    	//    	         	   fr->data_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+    	//    	          	   fr->data_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+    	//    	          	   fr->data_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+    	//    	           	   fr->data_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+    	//    	           	   fr->data_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+    	//    	          	   fr->data_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << endl;
     	//    	        cout <<  "\tBitlines (nJ): " <<
-    	//    	          	   fr->data_array2->power_bitlines.readOp.dynamic * 1e9 +
-    	//    	          	   fr->data_array2->power_prechg_eq_drivers.readOp.dynamic * 1e9<< endl;
+    	//    	          	   fr->data_array2.power_bitlines.readOp.dynamic * 1e9 +
+    	//    	          	   fr->data_array2.power_prechg_eq_drivers.readOp.dynamic * 1e9<< endl;
     	//    	        cout <<  "\tSense amplifier energy (nJ): " <<
-    	//    	          	   fr->data_array2->power_sense_amps.readOp.dynamic * 1e9 << endl;
+    	//    	          	   fr->data_array2.power_sense_amps.readOp.dynamic * 1e9 << endl;
     	//    	        cout <<  "\tSub-array output driver (nJ): " <<
-    	//    	          	   fr->data_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 << endl;
+    	//    	          	   fr->data_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 << endl;
     	//
     	//            	cout << endl <<"  Total leakage power of a bank (mW): " <<
-    	//                      fr->data_array2->power.readOp.leakage * 1e3 << endl;
+    	//                      fr->data_array2.power.readOp.leakage * 1e3 << endl;
     	//        }
     	//        else
     	//        {
     	if (g_ip->fully_assoc)  cout << "  Fully associative array:"<<endl;
 
     	cout << "  Total dynamic associative search energy/access  (nJ): " <<
-    			fr->data_array2->power.searchOp.dynamic * 1e9 ;
+    			fr->data_array2.power.searchOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power.searchOp.dynamic * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power.searchOp.dynamic * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout << "\tTotal energy in H-tree outside banks(that includes both "
     			"match key and data transfer) (nJ): " <<
-    			(fr->data_array2->power_routing_to_bank.searchOp.dynamic) * 1e9;
+    			(fr->data_array2.power_routing_to_bank.searchOp.dynamic) * 1e9;
         if (dvs)
          {
          	cout<<" (@DVS_Level0); ";
          	for (i = 0; i<dvs_levels; i++)
-         		cout<<fr->uca_q[i]->data_array2->power_routing_to_bank.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+         		cout<<fr->uca_q[i]->data_array2.power_routing_to_bank.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
          }
          cout<< endl;
 
     	cout << "\tMatch Key input Htrees inside bank Energy (nJ): " <<
-    	    			(fr->data_array2->power_htree_in_search.searchOp.dynamic ) * 1e9 ;
+    	    			(fr->data_array2.power_htree_in_search.searchOp.dynamic ) * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_htree_in_search.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_htree_in_search.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout << "\tResult output Htrees inside bank Energy (nJ): " <<
-    			(fr->data_array2->power_htree_out_search.searchOp.dynamic) * 1e9 ;
+    			(fr->data_array2.power_htree_out_search.searchOp.dynamic) * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_htree_out_search.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_htree_out_search.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tSearchlines (nJ): " <<
-    			fr->data_array2->power_searchline.searchOp.dynamic * 1e9 +
-    			fr->data_array2->power_searchline_precharge.searchOp.dynamic * 1e9 ;
+    			fr->data_array2.power_searchline.searchOp.dynamic * 1e9 +
+    			fr->data_array2.power_searchline_precharge.searchOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_searchline.searchOp.dynamic * 1e9 +
-    				  fr->uca_q[i]->data_array2->power_searchline_precharge.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_searchline.searchOp.dynamic * 1e9 +
+    				  fr->uca_q[i]->data_array2.power_searchline_precharge.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tMatchlines  (nJ): " <<
-    			fr->data_array2->power_matchlines.searchOp.dynamic * 1e9 +
-    			fr->data_array2->power_matchline_precharge.searchOp.dynamic * 1e9;
+    			fr->data_array2.power_matchlines.searchOp.dynamic * 1e9 +
+    			fr->data_array2.power_matchline_precharge.searchOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_matchlines.searchOp.dynamic * 1e9 +
-    				  fr->uca_q[i]->data_array2->power_matchline_precharge.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_matchlines.searchOp.dynamic * 1e9 +
+    				  fr->uca_q[i]->data_array2.power_matchline_precharge.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	if (g_ip->fully_assoc)
     	{
     		cout <<  "\tData portion wordline (nJ): " <<
-    				fr->data_array2->power_matchline_to_wordline_drv.searchOp.dynamic * 1e9 ;
+    				fr->data_array2.power_matchline_to_wordline_drv.searchOp.dynamic * 1e9 ;
             if (dvs)
             {
             	cout<<" (@DVS_Level0); ";
             	for (i = 0; i<dvs_levels; i++)
-            		cout<<fr->uca_q[i]->data_array2->power_matchline_to_wordline_drv.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+            		cout<<fr->uca_q[i]->data_array2.power_matchline_to_wordline_drv.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
             }
             cout<< endl;
 
     		cout <<  "\tData Bitlines (nJ): " <<
-    				fr->data_array2->power_bitlines.searchOp.dynamic * 1e9 +
-    				fr->data_array2->power_prechg_eq_drivers.searchOp.dynamic * 1e9;
+    				fr->data_array2.power_bitlines.searchOp.dynamic * 1e9 +
+    				fr->data_array2.power_prechg_eq_drivers.searchOp.dynamic * 1e9;
             if (dvs)
             {
             	cout<<" (@DVS_Level0); ";
             	for (i = 0; i<dvs_levels; i++)
-            		cout<<(fr->uca_q[i]->data_array2->power_bitlines.searchOp.dynamic * 1e9 +
-            			   fr->uca_q[i]->data_array2->power_prechg_eq_drivers.searchOp.dynamic * 1e9) <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+            		cout<<(fr->uca_q[i]->data_array2.power_bitlines.searchOp.dynamic * 1e9 +
+            			   fr->uca_q[i]->data_array2.power_prechg_eq_drivers.searchOp.dynamic * 1e9) <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
             }
             cout<< endl;
 
     		cout <<  "\tSense amplifier energy (nJ): " <<
-    				fr->data_array2->power_sense_amps.searchOp.dynamic * 1e9 ;
+    				fr->data_array2.power_sense_amps.searchOp.dynamic * 1e9 ;
             if (dvs)
             {
             	cout<<" (@DVS_Level0); ";
             	for (i = 0; i<dvs_levels; i++)
-            		cout<<fr->uca_q[i]->data_array2->power_sense_amps.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+            		cout<<fr->uca_q[i]->data_array2.power_sense_amps.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
             }
             cout<< endl;
     	}
 
     	cout <<  "\tSub-array output driver (nJ): " <<
-    			fr->data_array2->power_output_drivers_at_subarray.searchOp.dynamic * 1e9 ;
+    			fr->data_array2.power_output_drivers_at_subarray.searchOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_output_drivers_at_subarray.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_output_drivers_at_subarray.searchOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<endl<< "  Total dynamic read energy/access  (nJ): " <<
-    			fr->data_array2->power.readOp.dynamic * 1e9;
+    			fr->data_array2.power.readOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
 
     	cout << "\tTotal energy in H-tree outside banks(that includes both "
     			"address and data transfer) (nJ): " <<
-    			(fr->data_array2->power_routing_to_bank.readOp.dynamic) * 1e9;
+    			(fr->data_array2.power_routing_to_bank.readOp.dynamic) * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_routing_to_bank.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_routing_to_bank.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout << "\tInput Htree inside bank Energy (nJ): " <<
-    	    			(fr->data_array2->power_addr_input_htree.readOp.dynamic ) * 1e9 ;
+    	    			(fr->data_array2.power_addr_input_htree.readOp.dynamic ) * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_addr_input_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_addr_input_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout << "\tOutput Htree inside bank Energy (nJ): " <<
-    			fr->data_array2->power_data_output_htree.readOp.dynamic * 1e9 ;
+    			fr->data_array2.power_data_output_htree.readOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_data_output_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_data_output_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tDecoder (nJ): " <<
-    			fr->data_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9;
+    			fr->data_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<(fr->uca_q[i]->data_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
-    			       fr->uca_q[i]->data_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9) <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<(fr->uca_q[i]->data_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+    			       fr->uca_q[i]->data_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9) <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tWordline (nJ): " <<
-    			fr->data_array2->power_row_decoders.readOp.dynamic * 1e9 ;
+    			fr->data_array2.power_row_decoders.readOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_row_decoders.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_row_decoders.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tBitline mux & associated drivers (nJ): " <<
-    			fr->data_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_bit_mux_decoders.readOp.dynamic * 1e9;
+    			fr->data_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_bit_mux_decoders.readOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<(fr->uca_q[i]->data_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_bit_mux_decoders.readOp.dynamic * 1e9)
+        		cout<<(fr->uca_q[i]->data_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_bit_mux_decoders.readOp.dynamic * 1e9)
             			<<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tSense amp mux & associated drivers (nJ): " <<
-    			fr->data_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
-    			fr->data_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9;
+    			fr->data_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+    			fr->data_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<( fr->uca_q[i]->data_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
-            			fr->uca_q[i]->data_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
-            			fr->uca_q[i]->data_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9)
+        		cout<<( fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9)
             			<<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
 
     	cout <<  "\tBitlines (nJ): " <<
-    			fr->data_array2->power_bitlines.readOp.dynamic * 1e9 +
-    			fr->data_array2->power_prechg_eq_drivers.readOp.dynamic * 1e9;
+    			fr->data_array2.power_bitlines.readOp.dynamic * 1e9 +
+    			fr->data_array2.power_prechg_eq_drivers.readOp.dynamic * 1e9;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<(fr->uca_q[i]->data_array2->power_bitlines.readOp.dynamic * 1e9 +
-    			       fr->uca_q[i]->data_array2->power_prechg_eq_drivers.readOp.dynamic* 1e9) <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<(fr->uca_q[i]->data_array2.power_bitlines.readOp.dynamic * 1e9 +
+    			       fr->uca_q[i]->data_array2.power_prechg_eq_drivers.readOp.dynamic* 1e9) <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tSense amplifier energy (nJ): " <<
-    			fr->data_array2->power_sense_amps.readOp.dynamic * 1e9 ;
+    			fr->data_array2.power_sense_amps.readOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_sense_amps.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_sense_amps.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
     	cout <<  "\tSub-array output driver (nJ): " <<
-    			fr->data_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 ;
+    			fr->data_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 ;
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<fr->uca_q[i]->data_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<fr->uca_q[i]->data_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
 
     	cout << endl <<"  Total leakage power of a bank, including its network outside (mW): " <<
-    			(g_ip->long_channel_device ? fr->data_array2->power.readOp.leakage*long_channel_leakage_reduction : fr->data_array2->power.readOp.leakage)*1e3; //CAM/FA does not support PG yet
+    			(g_ip->long_channel_device ? fr->data_array2.power.readOp.leakage*long_channel_leakage_reduction : fr->data_array2.power.readOp.leakage)*1e3; //CAM/FA does not support PG yet
         if (dvs)
         {
         	cout<<" (@DVS_Level0); ";
         	for (i = 0; i<dvs_levels; i++)
-        		cout<<(g_ip->long_channel_device ?fr->uca_q[i]->data_array2->power.readOp.leakage*long_channel_leakage_reduction : fr->uca_q[i]->data_array2->power.readOp.leakage) * 1e3 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+        		cout<<(g_ip->long_channel_device ?fr->uca_q[i]->data_array2.power.readOp.leakage*long_channel_leakage_reduction : fr->uca_q[i]->data_array2.power.readOp.leakage) * 1e3 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
         }
         cout<< endl;
 
@@ -2951,161 +2953,161 @@ if(0){ //detailed power-gating output
     if ((!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) && !g_ip->is_main_mem)
     {
       cout << endl << "  Tag array:  Total dynamic read energy/access (nJ): " <<
-        fr->tag_array2->power.readOp.dynamic * 1e9;
+        fr->tag_array2.power.readOp.dynamic * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->power.readOp.dynamic * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.power.readOp.dynamic * 1e9  <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
       if (g_ip->power_gating)
             {
           	  cout << "\tTotal leakage power of a bank, power gated with retaining memory content, including its network outside (mW): " <<
-          			  (g_ip->long_channel_device ? fr->tag_array2->power.readOp.power_gated_leakage*long_channel_leakage_reduction :  fr->tag_array2->power.readOp.power_gated_leakage)* 1e3 << endl;
+          			  (g_ip->long_channel_device ? fr->tag_array2.power.readOp.power_gated_leakage*long_channel_leakage_reduction :  fr->tag_array2.power.readOp.power_gated_leakage)* 1e3 << endl;
           	 }
 //            else
 //            {
           	  cout << "\tTotal leakage power of a bank without power gating, including its network outside (mW): " <<
-          			(g_ip->long_channel_device ? fr->tag_array2->power.readOp.leakage * long_channel_leakage_reduction: fr->tag_array2->power.readOp.leakage)* 1e3;
+          			(g_ip->long_channel_device ? fr->tag_array2.power.readOp.leakage * long_channel_leakage_reduction: fr->tag_array2.power.readOp.leakage)* 1e3;
               if (dvs)
               {
               	cout<<" (@DVS_Level0); ";
               	for (i = 0; i<dvs_levels; i++)
-              		cout<<(g_ip->long_channel_device ? fr->uca_q[i]->tag_array2->power.readOp.leakage *long_channel_leakage_reduction: fr->uca_q[i]->tag_array2->power.readOp.leakage) * 1e3 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+              		cout<<(g_ip->long_channel_device ? fr->uca_q[i]->tag_array2.power.readOp.leakage *long_channel_leakage_reduction: fr->uca_q[i]->tag_array2.power.readOp.leakage) * 1e3 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
               }
               cout<< endl;
 
 //            }
 //      cout << "\tTotal leakage read/write power of a bank (mW): " <<
-//          fr->tag_array2->power.readOp.leakage * 1e3 << endl;
+//          fr->tag_array2.power.readOp.leakage * 1e3 << endl;
       cout << "\tTotal energy in H-tree outside banks (that includes both "
         "address and data transfer) (nJ): " <<
-          (fr->tag_array2->power_routing_to_bank.readOp.dynamic) * 1e9;
+          (fr->tag_array2.power_routing_to_bank.readOp.dynamic) * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->power_routing_to_bank.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.power_routing_to_bank.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
 
       cout << "\tInput H-tree inside banks Energy (nJ): " <<
-          (fr->tag_array2->power_addr_input_htree.readOp.dynamic) * 1e9;
+          (fr->tag_array2.power_addr_input_htree.readOp.dynamic) * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->power_addr_input_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.power_addr_input_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
       cout << "\tOutput Htree inside a bank Energy (nJ): " <<
-        fr->tag_array2->power_data_output_htree.readOp.dynamic * 1e9;
+        fr->tag_array2.power_data_output_htree.readOp.dynamic * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->power_data_output_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.power_data_output_htree.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
       cout <<  "\tDecoder (nJ): " <<
-        fr->tag_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
-        fr->tag_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9;
+        fr->tag_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+        fr->tag_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<(fr->uca_q[i]->tag_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
-  			       fr->uca_q[i]->tag_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9) <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<(fr->uca_q[i]->tag_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+  			       fr->uca_q[i]->tag_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9) <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
       cout <<  "\tWordline (nJ): " <<
-        fr->tag_array2->power_row_decoders.readOp.dynamic * 1e9;
+        fr->tag_array2.power_row_decoders.readOp.dynamic * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->power_row_decoders.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.power_row_decoders.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
       cout <<  "\tBitline mux & associated drivers (nJ): " <<
-        fr->tag_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
-        fr->tag_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
-        fr->tag_array2->power_bit_mux_decoders.readOp.dynamic * 1e9 ;
+        fr->tag_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+        fr->tag_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+        fr->tag_array2.power_bit_mux_decoders.readOp.dynamic * 1e9 ;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<(fr->uca_q[i]->tag_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
-          			fr->uca_q[i]->tag_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
-          			fr->uca_q[i]->tag_array2->power_bit_mux_decoders.readOp.dynamic * 1e9)
+      		cout<<(fr->uca_q[i]->tag_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+          			fr->uca_q[i]->tag_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+          			fr->uca_q[i]->tag_array2.power_bit_mux_decoders.readOp.dynamic * 1e9)
           			<<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
       cout <<  "\tSense amp mux & associated drivers (nJ): " <<
-        fr->tag_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
-        fr->tag_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
-        fr->tag_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
-        fr->tag_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
-        fr->tag_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
-        fr->tag_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9;
+        fr->tag_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+        fr->tag_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+        fr->tag_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+        fr->tag_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+        fr->tag_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+        fr->tag_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<( fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
-          			fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
-          			fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
-          			fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
-          			fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
-          			fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9)
+      		cout<<( fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+          			fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+          			fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+          			fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+          			fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+          			fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9)
           			<<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
       cout <<  "\tBitlines precharge and equalization circuit (nJ): " <<
-    		  fr->tag_array2->power_prechg_eq_drivers.readOp.dynamic * 1e9;
+    		  fr->tag_array2.power_prechg_eq_drivers.readOp.dynamic * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->power_prechg_eq_drivers.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.power_prechg_eq_drivers.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
       cout <<  "\tBitlines (nJ): " <<
-    		  fr->tag_array2->power_bitlines.readOp.dynamic * 1e9;
+    		  fr->tag_array2.power_bitlines.readOp.dynamic * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->power_bitlines.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.power_bitlines.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
       cout <<  "\tSense amplifier energy (nJ): " <<
-    		  fr->tag_array2->power_sense_amps.readOp.dynamic * 1e9;
+    		  fr->tag_array2.power_sense_amps.readOp.dynamic * 1e9;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->power_sense_amps.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.power_sense_amps.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
       cout <<  "\tSub-array output driver (nJ): " <<
-    		  fr->tag_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 ;
+    		  fr->tag_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 ;
       if (dvs)
       {
       	cout<<" (@DVS_Level0); ";
       	for (i = 0; i<dvs_levels; i++)
-      		cout<<fr->uca_q[i]->tag_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+      		cout<<fr->uca_q[i]->tag_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
       }
       cout<< endl;
 
@@ -3113,70 +3115,70 @@ if(0){ //detailed power-gating output
       {
     	  cout << "\tTotal leakage power in H-tree outside a bank when power gated (that includes both "
     			  "address and data network) ((mW)): " <<
-    			  (g_ip->long_channel_device ? fr->tag_array2->power_routing_to_bank.readOp.power_gated_leakage*long_channel_leakage_reduction : fr->tag_array2->power_routing_to_bank.readOp.power_gated_leakage) * 1e3 << endl;
+    			  (g_ip->long_channel_device ? fr->tag_array2.power_routing_to_bank.readOp.power_gated_leakage*long_channel_leakage_reduction : fr->tag_array2.power_routing_to_bank.readOp.power_gated_leakage) * 1e3 << endl;
       }
 //      else
 //      {
     	  cout << "\tTotal leakage power in H-tree outside a bank (that includes both "
     			  "address and data network) without power gating((mW)): " <<
-    			  (g_ip->long_channel_device ? fr->tag_array2->power_routing_to_bank.readOp.leakage*long_channel_leakage_reduction : fr->tag_array2->power_routing_to_bank.readOp.leakage) * 1e3;
+    			  (g_ip->long_channel_device ? fr->tag_array2.power_routing_to_bank.readOp.leakage*long_channel_leakage_reduction : fr->tag_array2.power_routing_to_bank.readOp.leakage) * 1e3;
           if (dvs)
           {
           	cout<<" (@DVS_Level0); ";
           	for (i = 0; i<dvs_levels; i++)
-          		cout<<(g_ip->long_channel_device ? fr->uca_q[i]->tag_array2->power_routing_to_bank.readOp.leakage *long_channel_leakage_reduction : fr->uca_q[i]->tag_array2->power_routing_to_bank.readOp.leakage) * 1e3 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
+          		cout<<(g_ip->long_channel_device ? fr->uca_q[i]->tag_array2.power_routing_to_bank.readOp.leakage *long_channel_leakage_reduction : fr->uca_q[i]->tag_array2.power_routing_to_bank.readOp.leakage) * 1e3 <<" (@DVS_Level"<< i+1<<"_Vdd=" << g_ip->dvs_voltage[i]<<"); ";
           }
           cout<< endl;
 //      }
 
 //    	cout << "\tTotal leakage power of a bank (mW): " <<
-//    	        fr->tag_array2->power.readOp.leakage * 1e3 << endl;
+//    	        fr->tag_array2.power.readOp.leakage * 1e3 << endl;
 //    	cout << "\tTotal leakage power in H-tree (that includes both "
 //    	      "address and data network) ((mW)): " <<
-//    	        (fr->tag_array2->power_addr_input_htree.readOp.leakage +
-//    	         fr->tag_array2->power_data_output_htree.readOp.leakage +
-//    	         fr->tag_array2->power_routing_to_bank.readOp.leakage) * 1e3 << endl;
+//    	        (fr->tag_array2.power_addr_input_htree.readOp.leakage +
+//    	         fr->tag_array2.power_data_output_htree.readOp.leakage +
+//    	         fr->tag_array2.power_routing_to_bank.readOp.leakage) * 1e3 << endl;
 //
 //    	cout << "\tTotal leakage power in cells (mW): " <<
-//    	        (fr->tag_array2->array_leakage) * 1e3 << endl;
+//    	        (fr->tag_array2.array_leakage) * 1e3 << endl;
 //    	cout << "\tTotal leakage power in row logic(mW): " <<
-//    	        (fr->tag_array2->wl_leakage) * 1e3 << endl;
+//    	        (fr->tag_array2.wl_leakage) * 1e3 << endl;
 //    	cout << "\tTotal leakage power in column logic(mW): " <<
-//    	        (fr->tag_array2->cl_leakage) * 1e3 << endl;
+//    	        (fr->tag_array2.cl_leakage) * 1e3 << endl;
 //    	cout << "\tTotal gate leakage power in H-tree (that includes both "
 //    	      "address and data network) ((mW)): " <<
-//    	        (fr->tag_array2->power_addr_input_htree.readOp.gate_leakage +
-//    	         fr->tag_array2->power_data_output_htree.readOp.gate_leakage +
-//    	         fr->tag_array2->power_routing_to_bank.readOp.gate_leakage) * 1e3 << endl;
+//    	        (fr->tag_array2.power_addr_input_htree.readOp.gate_leakage +
+//    	         fr->tag_array2.power_data_output_htree.readOp.gate_leakage +
+//    	         fr->tag_array2.power_routing_to_bank.readOp.gate_leakage) * 1e3 << endl;
     }
 
     cout << endl << endl <<  "Area Components:" << endl << endl;
     /* Data array area stats */
     if (!(g_ip->pure_cam || g_ip->fully_assoc))
-    	cout <<  "  Data array: Area (mm2): " << fr->data_array2->area * 1e-6 << endl;
+    	cout <<  "  Data array: Area (mm2): " << fr->data_array2.area * 1e-6 << endl;
     else if (g_ip->pure_cam)
-    	cout <<  "  CAM array: Area (mm2): " << fr->data_array2->area * 1e-6 << endl;
+    	cout <<  "  CAM array: Area (mm2): " << fr->data_array2.area * 1e-6 << endl;
     else
-    	cout <<  "  Fully associative cache array: Area (mm2): " << fr->data_array2->area * 1e-6 << endl;
+    	cout <<  "  Fully associative cache array: Area (mm2): " << fr->data_array2.area * 1e-6 << endl;
 
     cout <<  "\tHeight (mm): " <<
-      fr->data_array2->all_banks_height*1e-3 << endl;
+      fr->data_array2.all_banks_height*1e-3 << endl;
     cout <<  "\tWidth (mm): " <<
-      fr->data_array2->all_banks_width*1e-3 << endl;
+      fr->data_array2.all_banks_width*1e-3 << endl;
     if (g_ip->print_detail) {
       cout <<  "\tArea efficiency (Memory cell area/Total area) - " <<
-        fr->data_array2->area_efficiency << " %" << endl;
+        fr->data_array2.area_efficiency << " %" << endl;
       cout << "\t\tMAT Height (mm): " <<
-        fr->data_array2->mat_height*1e-3 << endl;
+        fr->data_array2.mat_height*1e-3 << endl;
       cout << "\t\tMAT Length (mm): " <<
-        fr->data_array2->mat_length*1e-3 << endl;
+        fr->data_array2.mat_length*1e-3 << endl;
       cout << "\t\tSubarray Height (mm): " <<
-        fr->data_array2->subarray_height*1e-3 << endl;
+        fr->data_array2.subarray_height*1e-3 << endl;
       cout << "\t\tSubarray Length (mm): " <<
-    		  fr->data_array2->subarray_length*1e-3 << endl;
+    		  fr->data_array2.subarray_length*1e-3 << endl;
       if (g_ip->power_gating)
       {
-    	  overhead_data = (fr->data_array2->area/fr->uca_pg_reference->data_array2->area-1)*100;//%;
+    	  overhead_data = (fr->data_array2.area/fr->uca_pg_reference->data_array2.area-1)*100;//%;
     	  cout <<  "  Power gating circuits (sleep transistors) induced area overhead: " << overhead_data <<"%" <<endl;
       }
     }
@@ -3184,29 +3186,29 @@ if(0){ //detailed power-gating output
     /* Tag array area stats */
     if ((!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) && !g_ip->is_main_mem)
     {
-      cout << endl << "  Tag array: Area (mm2): " << fr->tag_array2->area * 1e-6 << endl;
+      cout << endl << "  Tag array: Area (mm2): " << fr->tag_array2.area * 1e-6 << endl;
       cout <<  "\tHeight (mm): " <<
-        fr->tag_array2->all_banks_height*1e-3 << endl;
+        fr->tag_array2.all_banks_height*1e-3 << endl;
       cout <<  "\tWidth (mm): " <<
-        fr->tag_array2->all_banks_width*1e-3 << endl;
+        fr->tag_array2.all_banks_width*1e-3 << endl;
 
       if (g_ip->print_detail)
       {
         cout <<  "\tArea efficiency (Memory cell area/Total area) - " <<
-          fr->tag_array2->area_efficiency << " %" << endl;
+          fr->tag_array2.area_efficiency << " %" << endl;
       cout << "\t\tMAT Height (mm): " <<
-        fr->tag_array2->mat_height*1e-3 << endl;
+        fr->tag_array2.mat_height*1e-3 << endl;
       cout << "\t\tMAT Length (mm): " <<
-        fr->tag_array2->mat_length*1e-3 << endl;
+        fr->tag_array2.mat_length*1e-3 << endl;
       cout << "\t\tSubarray Height (mm): " <<
-        fr->tag_array2->subarray_height*1e-3 << endl;
+        fr->tag_array2.subarray_height*1e-3 << endl;
       cout << "\t\tSubarray Length (mm): " <<
-    		  fr->tag_array2->subarray_length*1e-3 << endl;
+    		  fr->tag_array2.subarray_length*1e-3 << endl;
       }
 
       if (g_ip->power_gating)
       {
-    	  overhead_tag = (fr->tag_array2->area/fr->uca_pg_reference->tag_array2->area-1)*100;//%;
+    	  overhead_tag = (fr->tag_array2.area/fr->uca_pg_reference->tag_array2.area-1)*100;//%;
     	  cout <<  "  Power gating circuits (sleep transistors) induced area overhead: " << overhead_tag <<"%" <<endl<<endl;
       }
     }
@@ -3348,8 +3350,59 @@ uca_org_t cacti_interface(InputParameter  * const local_interface)
   init_tech_params(g_ip->F_sz_um, false);
   Wire winit; // Do not delete this line. It initializes wires.
 
+
+#ifdef ENABLE_CACHE
+  static DB *dbp = NULL;
+
+  if (dbp == NULL)
+  {
+    char filename[1024];
+    snprintf(filename, 1024, "%s/mcpat-%s.db", getenv("TMPDIR") ? getenv("TMPDIR") : "/tmp", getenv("USER"));
+    db_create(&dbp, NULL, 0);
+    dbp->open(dbp, NULL, filename, NULL, DB_HASH, DB_CREATE, 0);
+  }
+
+  DBT key, data;
+  memset(&key, 0, sizeof(DBT));
+  memset(&data, 0, sizeof(DBT));
+
+  size_t o1 = offsetof(InputParameter, first),
+         o2 = offsetof(InputParameter, last);
+
+  // Create a clean copy of our input parameters, with zeroes on all unused locations
+  InputParameter clean_ip;
+  memset((char*)&clean_ip + o1, 0, o2 - o1); // Set everything to zero
+  clean_ip = *g_ip; // Copies over actual (used) data
+
+  key.data = (char*)&clean_ip + o1;
+  key.size = o2 - o1;
+
+  if (DB_NOTFOUND == dbp->get(dbp, NULL, &key, &data, 0) /* Not found in DB */
+      || sizeof(fin_res) != data.size /* Or from a different version */)
+  {
     solve(&fin_res);
 
+    // If found (but size is wrong): delete it
+    if (DB_NOTFOUND != dbp->get(dbp, NULL, &key, &data, 0))
+      dbp->del(dbp, NULL, &key, 0);
+
+    data.data = &fin_res;
+    data.size = sizeof(fin_res);
+    int res = dbp->put(dbp, NULL, &key, &data, DB_NOOVERWRITE);
+    if (res)
+      printf("DB write error: %d\n", res);
+    dbp->sync(dbp, 0);
+  }
+  else
+  {
+    assert(sizeof(fin_res) == data.size);
+    memcpy(&fin_res, data.data, sizeof(fin_res));
+  }
+#else
+  solve(&fin_res);
+#endif
+
+
   if (!g_ip->dvs_voltage.empty())
   {
 	  update_dvs(&fin_res);
diff --git a/cacti/nuca.cc b/cacti/nuca.cc
index 230025c..79364b3 100644
--- a/cacti/nuca.cc
+++ b/cacti/nuca.cc
@@ -236,8 +236,8 @@ Nuca::sim_nuca()
   }
   cout << "Simulating various NUCA configurations\n";
   for (it=bank_start; it<iterations; it++) { /* different bank count values */
-    ures.tag_array2 = &tag;
-    ures.data_array2 = &data;
+    ures.tag_array2 = tag;
+    ures.data_array2 = data;
     /*
      * find the optimal bank organization
      */
diff --git a/core.cc b/core.cc
index 41b74fe..78d3194 100644
--- a/core.cc
+++ b/core.cc
@@ -3156,7 +3156,7 @@ void LoadStoreU::computeEnergy(bool is_tdp)
 	LSQ->power_t.reset();
     dcache.power_t.readOp.dynamic	+= (dcache.caches->stats_t.readAc.hit*dcache.caches->local_result.power.readOp.dynamic+
     		dcache.caches->stats_t.readAc.miss*dcache.caches->local_result.power.readOp.dynamic+ //assuming D cache is in the fast model which read tag and data together
-    		dcache.caches->stats_t.writeAc.miss*dcache.caches->local_result.tag_array2->power.readOp.dynamic+
+    		dcache.caches->stats_t.writeAc.miss*dcache.caches->local_result.tag_array2.power.readOp.dynamic+
     		dcache.caches->stats_t.writeAc.access*dcache.caches->local_result.power.writeOp.dynamic);
 
     if (cache_p==Write_back)
diff --git a/mcpat.mk b/mcpat.mk
index f2c4fd5..60b8a03 100644
--- a/mcpat.mk
+++ b/mcpat.mk
@@ -20,10 +20,19 @@ else
   #OPT = -O0 -DNTHREADS=$(NTHREADS)
 endif
 
+ifeq ($(ARCH),ia32)
+  OPT += -m32
+endif
+
+ifneq ($(CACHE),)
+  OPT += -DENABLE_CACHE
+  LIBS += -ldb
+endif
+
 #CXXFLAGS = -Wall -Wno-unknown-pragmas -Winline $(DBG) $(OPT)
 CXXFLAGS = -Wno-unknown-pragmas $(DBG) $(OPT)
-CXX = g++ -m32
-CC  = gcc -m32
+CXX = g++
+CC  = gcc
 
 VPATH = cacti
 
@@ -65,7 +74,7 @@ SRCS  = \
 OBJS = $(patsubst %.cc,obj_$(TAG)/%.o,$(SRCS))
 
 all: obj_$(TAG)/$(TARGET)
-	cp -f obj_$(TAG)/$(TARGET) $(TARGET)
+	cp -f obj_$(TAG)/$(TARGET) $(TARGET)$(SUFFIX)
 
 obj_$(TAG)/$(TARGET) : $(OBJS)
 	$(CXX) $(OBJS) -o $@ $(INCS) $(CXXFLAGS) $(LIBS) -pthread
diff --git a/sharedcache.cc b/sharedcache.cc
index 98f466d..220ee64 100644
--- a/sharedcache.cc
+++ b/sharedcache.cc
@@ -764,18 +764,18 @@ void SharedCache::computeEnergy(bool is_tdp)
 	if (!((cachep.dir_ty==ST&& cacheL==L1Directory)||(cachep.dir_ty==ST&& cacheL==L2Directory)))
 	{
 		unicache.power_t.readOp.dynamic	+= (unicache.caches->stats_t.readAc.hit*unicache.caches->local_result.power.readOp.dynamic+
-				unicache.caches->stats_t.readAc.miss*unicache.caches->local_result.tag_array2->power.readOp.dynamic+
-				unicache.caches->stats_t.writeAc.miss*unicache.caches->local_result.tag_array2->power.writeOp.dynamic+
+				unicache.caches->stats_t.readAc.miss*unicache.caches->local_result.tag_array2.power.readOp.dynamic+
+				unicache.caches->stats_t.writeAc.miss*unicache.caches->local_result.tag_array2.power.writeOp.dynamic+
 				unicache.caches->stats_t.writeAc.access*unicache.caches->local_result.power.writeOp.dynamic);//write miss will also generate a write later
 
 		if (cachep.dir_ty==SBT)
 		{
-			unicache.power_t.readOp.dynamic	+= homenode_stats_t.readAc.hit * (unicache.caches->local_result.data_array2->power.readOp.dynamic*dir_overhead +
-						unicache.caches->local_result.tag_array2->power.readOp.dynamic) +
-					homenode_stats_t.readAc.miss*unicache.caches->local_result.tag_array2->power.readOp.dynamic +
-					homenode_stats_t.writeAc.miss*unicache.caches->local_result.tag_array2->power.readOp.dynamic +
-			        homenode_stats_t.writeAc.hit*(unicache.caches->local_result.data_array2->power.writeOp.dynamic*dir_overhead +
-							unicache.caches->local_result.tag_array2->power.readOp.dynamic+
+			unicache.power_t.readOp.dynamic	+= homenode_stats_t.readAc.hit * (unicache.caches->local_result.data_array2.power.readOp.dynamic*dir_overhead +
+						unicache.caches->local_result.tag_array2.power.readOp.dynamic) +
+					homenode_stats_t.readAc.miss*unicache.caches->local_result.tag_array2.power.readOp.dynamic +
+					homenode_stats_t.writeAc.miss*unicache.caches->local_result.tag_array2.power.readOp.dynamic +
+			        homenode_stats_t.writeAc.hit*(unicache.caches->local_result.data_array2.power.writeOp.dynamic*dir_overhead +
+							unicache.caches->local_result.tag_array2.power.readOp.dynamic+
 					homenode_stats_t.writeAc.miss*unicache.caches->local_result.power.writeOp.dynamic);//write miss on dynamic home node will generate a replacement write on whole cache block
 
 
